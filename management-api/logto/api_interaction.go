/*
Logto API references

API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.

API version: Cloud
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package logto

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InteractionAPIService InteractionAPI service
type InteractionAPIService service

type ApiApiInteractionBindMfaPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionBindMfaPostRequest *ApiInteractionBindMfaPostRequest
}

func (r ApiApiInteractionBindMfaPostRequest) ApiInteractionBindMfaPostRequest(apiInteractionBindMfaPostRequest ApiInteractionBindMfaPostRequest) ApiApiInteractionBindMfaPostRequest {
	r.apiInteractionBindMfaPostRequest = &apiInteractionBindMfaPostRequest
	return r
}

func (r ApiApiInteractionBindMfaPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionBindMfaPostExecute(r)
}

/*
ApiInteractionBindMfaPost Method for ApiInteractionBindMfaPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionBindMfaPostRequest
*/
func (a *InteractionAPIService) ApiInteractionBindMfaPost(ctx context.Context) ApiApiInteractionBindMfaPostRequest {
	return ApiApiInteractionBindMfaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionBindMfaPostExecute(r ApiApiInteractionBindMfaPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionBindMfaPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/bind-mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionBindMfaPostRequest == nil {
		return nil, reportError("apiInteractionBindMfaPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionBindMfaPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionConsentGetRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
}

func (r ApiApiInteractionConsentGetRequest) Execute() (*ApiInteractionConsentGet200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionConsentGetExecute(r)
}

/*
ApiInteractionConsentGet Method for ApiInteractionConsentGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionConsentGetRequest
*/
func (a *InteractionAPIService) ApiInteractionConsentGet(ctx context.Context) ApiApiInteractionConsentGetRequest {
	return ApiApiInteractionConsentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiInteractionConsentGet200Response
func (a *InteractionAPIService) ApiInteractionConsentGetExecute(r ApiApiInteractionConsentGetRequest) (*ApiInteractionConsentGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiInteractionConsentGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionConsentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/consent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionConsentPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionConsentPostRequest *ApiInteractionConsentPostRequest
}

func (r ApiApiInteractionConsentPostRequest) ApiInteractionConsentPostRequest(apiInteractionConsentPostRequest ApiInteractionConsentPostRequest) ApiApiInteractionConsentPostRequest {
	r.apiInteractionConsentPostRequest = &apiInteractionConsentPostRequest
	return r
}

func (r ApiApiInteractionConsentPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionConsentPostExecute(r)
}

/*
ApiInteractionConsentPost Method for ApiInteractionConsentPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionConsentPostRequest
*/
func (a *InteractionAPIService) ApiInteractionConsentPost(ctx context.Context) ApiApiInteractionConsentPostRequest {
	return ApiApiInteractionConsentPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionConsentPostExecute(r ApiApiInteractionConsentPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionConsentPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/consent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionConsentPostRequest == nil {
		return nil, reportError("apiInteractionConsentPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionConsentPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionDeleteRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
}

func (r ApiApiInteractionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionDeleteExecute(r)
}

/*
ApiInteractionDelete Method for ApiInteractionDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionDeleteRequest
*/
func (a *InteractionAPIService) ApiInteractionDelete(ctx context.Context) ApiApiInteractionDeleteRequest {
	return ApiApiInteractionDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionDeleteExecute(r ApiApiInteractionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionEventPutRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionEventPutRequest *ApiInteractionEventPutRequest
}

func (r ApiApiInteractionEventPutRequest) ApiInteractionEventPutRequest(apiInteractionEventPutRequest ApiInteractionEventPutRequest) ApiApiInteractionEventPutRequest {
	r.apiInteractionEventPutRequest = &apiInteractionEventPutRequest
	return r
}

func (r ApiApiInteractionEventPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionEventPutExecute(r)
}

/*
ApiInteractionEventPut Method for ApiInteractionEventPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionEventPutRequest
*/
func (a *InteractionAPIService) ApiInteractionEventPut(ctx context.Context) ApiApiInteractionEventPutRequest {
	return ApiApiInteractionEventPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionEventPutExecute(r ApiApiInteractionEventPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionEventPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/event"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionEventPutRequest == nil {
		return nil, reportError("apiInteractionEventPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionEventPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionIdentifiersPatchRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionPutRequestIdentifier *ApiInteractionPutRequestIdentifier
}

func (r ApiApiInteractionIdentifiersPatchRequest) ApiInteractionPutRequestIdentifier(apiInteractionPutRequestIdentifier ApiInteractionPutRequestIdentifier) ApiApiInteractionIdentifiersPatchRequest {
	r.apiInteractionPutRequestIdentifier = &apiInteractionPutRequestIdentifier
	return r
}

func (r ApiApiInteractionIdentifiersPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionIdentifiersPatchExecute(r)
}

/*
ApiInteractionIdentifiersPatch Method for ApiInteractionIdentifiersPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionIdentifiersPatchRequest
*/
func (a *InteractionAPIService) ApiInteractionIdentifiersPatch(ctx context.Context) ApiApiInteractionIdentifiersPatchRequest {
	return ApiApiInteractionIdentifiersPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionIdentifiersPatchExecute(r ApiApiInteractionIdentifiersPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionIdentifiersPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/identifiers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionPutRequestIdentifier == nil {
		return nil, reportError("apiInteractionPutRequestIdentifier is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionPutRequestIdentifier
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionMfaPutRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionMfaPutRequest *ApiInteractionMfaPutRequest
}

func (r ApiApiInteractionMfaPutRequest) ApiInteractionMfaPutRequest(apiInteractionMfaPutRequest ApiInteractionMfaPutRequest) ApiApiInteractionMfaPutRequest {
	r.apiInteractionMfaPutRequest = &apiInteractionMfaPutRequest
	return r
}

func (r ApiApiInteractionMfaPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionMfaPutExecute(r)
}

/*
ApiInteractionMfaPut Method for ApiInteractionMfaPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionMfaPutRequest
*/
func (a *InteractionAPIService) ApiInteractionMfaPut(ctx context.Context) ApiApiInteractionMfaPutRequest {
	return ApiApiInteractionMfaPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionMfaPutExecute(r ApiApiInteractionMfaPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionMfaPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionMfaPutRequest == nil {
		return nil, reportError("apiInteractionMfaPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionMfaPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionMfaSkippedPutRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionMfaSkippedPutRequest *ApiInteractionMfaSkippedPutRequest
}

func (r ApiApiInteractionMfaSkippedPutRequest) ApiInteractionMfaSkippedPutRequest(apiInteractionMfaSkippedPutRequest ApiInteractionMfaSkippedPutRequest) ApiApiInteractionMfaSkippedPutRequest {
	r.apiInteractionMfaSkippedPutRequest = &apiInteractionMfaSkippedPutRequest
	return r
}

func (r ApiApiInteractionMfaSkippedPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionMfaSkippedPutExecute(r)
}

/*
ApiInteractionMfaSkippedPut Method for ApiInteractionMfaSkippedPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionMfaSkippedPutRequest
*/
func (a *InteractionAPIService) ApiInteractionMfaSkippedPut(ctx context.Context) ApiApiInteractionMfaSkippedPutRequest {
	return ApiApiInteractionMfaSkippedPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionMfaSkippedPutExecute(r ApiApiInteractionMfaSkippedPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionMfaSkippedPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/mfa-skipped"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionMfaSkippedPutRequest == nil {
		return nil, reportError("apiInteractionMfaSkippedPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionMfaSkippedPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionProfileDeleteRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
}

func (r ApiApiInteractionProfileDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionProfileDeleteExecute(r)
}

/*
ApiInteractionProfileDelete Method for ApiInteractionProfileDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionProfileDeleteRequest
*/
func (a *InteractionAPIService) ApiInteractionProfileDelete(ctx context.Context) ApiApiInteractionProfileDeleteRequest {
	return ApiApiInteractionProfileDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionProfileDeleteExecute(r ApiApiInteractionProfileDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionProfileDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionProfilePatchRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionPutRequestProfile *ApiInteractionPutRequestProfile
}

func (r ApiApiInteractionProfilePatchRequest) ApiInteractionPutRequestProfile(apiInteractionPutRequestProfile ApiInteractionPutRequestProfile) ApiApiInteractionProfilePatchRequest {
	r.apiInteractionPutRequestProfile = &apiInteractionPutRequestProfile
	return r
}

func (r ApiApiInteractionProfilePatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionProfilePatchExecute(r)
}

/*
ApiInteractionProfilePatch Method for ApiInteractionProfilePatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionProfilePatchRequest
*/
func (a *InteractionAPIService) ApiInteractionProfilePatch(ctx context.Context) ApiApiInteractionProfilePatchRequest {
	return ApiApiInteractionProfilePatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionProfilePatchExecute(r ApiApiInteractionProfilePatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionProfilePatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionPutRequestProfile == nil {
		return nil, reportError("apiInteractionPutRequestProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionPutRequestProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionProfilePutRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionPutRequestProfile *ApiInteractionPutRequestProfile
}

func (r ApiApiInteractionProfilePutRequest) ApiInteractionPutRequestProfile(apiInteractionPutRequestProfile ApiInteractionPutRequestProfile) ApiApiInteractionProfilePutRequest {
	r.apiInteractionPutRequestProfile = &apiInteractionPutRequestProfile
	return r
}

func (r ApiApiInteractionProfilePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionProfilePutExecute(r)
}

/*
ApiInteractionProfilePut Method for ApiInteractionProfilePut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionProfilePutRequest
*/
func (a *InteractionAPIService) ApiInteractionProfilePut(ctx context.Context) ApiApiInteractionProfilePutRequest {
	return ApiApiInteractionProfilePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionProfilePutExecute(r ApiApiInteractionProfilePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionProfilePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionPutRequestProfile == nil {
		return nil, reportError("apiInteractionPutRequestProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionPutRequestProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionPutRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionPutRequest *ApiInteractionPutRequest
}

func (r ApiApiInteractionPutRequest) ApiInteractionPutRequest(apiInteractionPutRequest ApiInteractionPutRequest) ApiApiInteractionPutRequest {
	r.apiInteractionPutRequest = &apiInteractionPutRequest
	return r
}

func (r ApiApiInteractionPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionPutExecute(r)
}

/*
ApiInteractionPut Method for ApiInteractionPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionPutRequest
*/
func (a *InteractionAPIService) ApiInteractionPut(ctx context.Context) ApiApiInteractionPutRequest {
	return ApiApiInteractionPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionPutExecute(r ApiApiInteractionPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionPutRequest == nil {
		return nil, reportError("apiInteractionPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionSingleSignOnConnectorIdAuthenticationPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	connectorId string
	requestBody *map[string]interface{}
}

func (r ApiApiInteractionSingleSignOnConnectorIdAuthenticationPostRequest) RequestBody(requestBody map[string]interface{}) ApiApiInteractionSingleSignOnConnectorIdAuthenticationPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiApiInteractionSingleSignOnConnectorIdAuthenticationPostRequest) Execute() (*SubmitInteraction200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionSingleSignOnConnectorIdAuthenticationPostExecute(r)
}

/*
ApiInteractionSingleSignOnConnectorIdAuthenticationPost Method for ApiInteractionSingleSignOnConnectorIdAuthenticationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiApiInteractionSingleSignOnConnectorIdAuthenticationPostRequest
*/
func (a *InteractionAPIService) ApiInteractionSingleSignOnConnectorIdAuthenticationPost(ctx context.Context, connectorId string) ApiApiInteractionSingleSignOnConnectorIdAuthenticationPostRequest {
	return ApiApiInteractionSingleSignOnConnectorIdAuthenticationPostRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
//  @return SubmitInteraction200Response
func (a *InteractionAPIService) ApiInteractionSingleSignOnConnectorIdAuthenticationPostExecute(r ApiApiInteractionSingleSignOnConnectorIdAuthenticationPostRequest) (*SubmitInteraction200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitInteraction200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionSingleSignOnConnectorIdAuthenticationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/single-sign-on/{connectorId}/authentication"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	connectorId string
	apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest *ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
}

func (r ApiApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest) ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest(apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest) ApiApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest {
	r.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest = &apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
	return r
}

func (r ApiApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest) Execute() (*SubmitInteraction200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostExecute(r)
}

/*
ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPost Method for ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
*/
func (a *InteractionAPIService) ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(ctx context.Context, connectorId string) ApiApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest {
	return ApiApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
//  @return SubmitInteraction200Response
func (a *InteractionAPIService) ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostExecute(r ApiApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest) (*SubmitInteraction200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitInteraction200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/single-sign-on/{connectorId}/authorization-url"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest == nil {
		return localVarReturnValue, nil, reportError("apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionSingleSignOnConnectorIdRegistrationPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	connectorId string
}

func (r ApiApiInteractionSingleSignOnConnectorIdRegistrationPostRequest) Execute() (*SubmitInteraction200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionSingleSignOnConnectorIdRegistrationPostExecute(r)
}

/*
ApiInteractionSingleSignOnConnectorIdRegistrationPost Method for ApiInteractionSingleSignOnConnectorIdRegistrationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiApiInteractionSingleSignOnConnectorIdRegistrationPostRequest
*/
func (a *InteractionAPIService) ApiInteractionSingleSignOnConnectorIdRegistrationPost(ctx context.Context, connectorId string) ApiApiInteractionSingleSignOnConnectorIdRegistrationPostRequest {
	return ApiApiInteractionSingleSignOnConnectorIdRegistrationPostRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
//  @return SubmitInteraction200Response
func (a *InteractionAPIService) ApiInteractionSingleSignOnConnectorIdRegistrationPostExecute(r ApiApiInteractionSingleSignOnConnectorIdRegistrationPostRequest) (*SubmitInteraction200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitInteraction200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionSingleSignOnConnectorIdRegistrationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/single-sign-on/{connectorId}/registration"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionSingleSignOnConnectorsGetRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	email *string
}

func (r ApiApiInteractionSingleSignOnConnectorsGetRequest) Email(email string) ApiApiInteractionSingleSignOnConnectorsGetRequest {
	r.email = &email
	return r
}

func (r ApiApiInteractionSingleSignOnConnectorsGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ApiInteractionSingleSignOnConnectorsGetExecute(r)
}

/*
ApiInteractionSingleSignOnConnectorsGet Method for ApiInteractionSingleSignOnConnectorsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionSingleSignOnConnectorsGetRequest
*/
func (a *InteractionAPIService) ApiInteractionSingleSignOnConnectorsGet(ctx context.Context) ApiApiInteractionSingleSignOnConnectorsGetRequest {
	return ApiApiInteractionSingleSignOnConnectorsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *InteractionAPIService) ApiInteractionSingleSignOnConnectorsGetExecute(r ApiApiInteractionSingleSignOnConnectorsGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionSingleSignOnConnectorsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/single-sign-on/connectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionSubmitPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
}

func (r ApiApiInteractionSubmitPostRequest) Execute() (*SubmitInteraction200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionSubmitPostExecute(r)
}

/*
ApiInteractionSubmitPost Method for ApiInteractionSubmitPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionSubmitPostRequest
*/
func (a *InteractionAPIService) ApiInteractionSubmitPost(ctx context.Context) ApiApiInteractionSubmitPostRequest {
	return ApiApiInteractionSubmitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitInteraction200Response
func (a *InteractionAPIService) ApiInteractionSubmitPostExecute(r ApiApiInteractionSubmitPostRequest) (*SubmitInteraction200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitInteraction200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionVerificationSocialAuthorizationUriPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	apiInteractionVerificationSocialAuthorizationUriPostRequest *ApiInteractionVerificationSocialAuthorizationUriPostRequest
}

func (r ApiApiInteractionVerificationSocialAuthorizationUriPostRequest) ApiInteractionVerificationSocialAuthorizationUriPostRequest(apiInteractionVerificationSocialAuthorizationUriPostRequest ApiInteractionVerificationSocialAuthorizationUriPostRequest) ApiApiInteractionVerificationSocialAuthorizationUriPostRequest {
	r.apiInteractionVerificationSocialAuthorizationUriPostRequest = &apiInteractionVerificationSocialAuthorizationUriPostRequest
	return r
}

func (r ApiApiInteractionVerificationSocialAuthorizationUriPostRequest) Execute() (*SubmitInteraction200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionVerificationSocialAuthorizationUriPostExecute(r)
}

/*
ApiInteractionVerificationSocialAuthorizationUriPost Method for ApiInteractionVerificationSocialAuthorizationUriPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionVerificationSocialAuthorizationUriPostRequest
*/
func (a *InteractionAPIService) ApiInteractionVerificationSocialAuthorizationUriPost(ctx context.Context) ApiApiInteractionVerificationSocialAuthorizationUriPostRequest {
	return ApiApiInteractionVerificationSocialAuthorizationUriPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitInteraction200Response
func (a *InteractionAPIService) ApiInteractionVerificationSocialAuthorizationUriPostExecute(r ApiApiInteractionVerificationSocialAuthorizationUriPostRequest) (*SubmitInteraction200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitInteraction200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionVerificationSocialAuthorizationUriPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/verification/social-authorization-uri"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiInteractionVerificationSocialAuthorizationUriPostRequest == nil {
		return localVarReturnValue, nil, reportError("apiInteractionVerificationSocialAuthorizationUriPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiInteractionVerificationSocialAuthorizationUriPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionVerificationTotpPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
}

func (r ApiApiInteractionVerificationTotpPostRequest) Execute() (*ApiInteractionVerificationTotpPost200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionVerificationTotpPostExecute(r)
}

/*
ApiInteractionVerificationTotpPost Method for ApiInteractionVerificationTotpPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionVerificationTotpPostRequest
*/
func (a *InteractionAPIService) ApiInteractionVerificationTotpPost(ctx context.Context) ApiApiInteractionVerificationTotpPostRequest {
	return ApiApiInteractionVerificationTotpPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiInteractionVerificationTotpPost200Response
func (a *InteractionAPIService) ApiInteractionVerificationTotpPostExecute(r ApiApiInteractionVerificationTotpPostRequest) (*ApiInteractionVerificationTotpPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiInteractionVerificationTotpPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionVerificationTotpPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/verification/totp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionVerificationVerificationCodePostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
	createVerificationCodeRequest *CreateVerificationCodeRequest
}

func (r ApiApiInteractionVerificationVerificationCodePostRequest) CreateVerificationCodeRequest(createVerificationCodeRequest CreateVerificationCodeRequest) ApiApiInteractionVerificationVerificationCodePostRequest {
	r.createVerificationCodeRequest = &createVerificationCodeRequest
	return r
}

func (r ApiApiInteractionVerificationVerificationCodePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiInteractionVerificationVerificationCodePostExecute(r)
}

/*
ApiInteractionVerificationVerificationCodePost Method for ApiInteractionVerificationVerificationCodePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionVerificationVerificationCodePostRequest
*/
func (a *InteractionAPIService) ApiInteractionVerificationVerificationCodePost(ctx context.Context) ApiApiInteractionVerificationVerificationCodePostRequest {
	return ApiApiInteractionVerificationVerificationCodePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InteractionAPIService) ApiInteractionVerificationVerificationCodePostExecute(r ApiApiInteractionVerificationVerificationCodePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionVerificationVerificationCodePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/verification/verification-code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVerificationCodeRequest == nil {
		return nil, reportError("createVerificationCodeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVerificationCodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiInteractionVerificationWebauthnAuthenticationPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
}

func (r ApiApiInteractionVerificationWebauthnAuthenticationPostRequest) Execute() (*ApiInteractionVerificationWebauthnAuthenticationPost200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionVerificationWebauthnAuthenticationPostExecute(r)
}

/*
ApiInteractionVerificationWebauthnAuthenticationPost Method for ApiInteractionVerificationWebauthnAuthenticationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionVerificationWebauthnAuthenticationPostRequest
*/
func (a *InteractionAPIService) ApiInteractionVerificationWebauthnAuthenticationPost(ctx context.Context) ApiApiInteractionVerificationWebauthnAuthenticationPostRequest {
	return ApiApiInteractionVerificationWebauthnAuthenticationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiInteractionVerificationWebauthnAuthenticationPost200Response
func (a *InteractionAPIService) ApiInteractionVerificationWebauthnAuthenticationPostExecute(r ApiApiInteractionVerificationWebauthnAuthenticationPostRequest) (*ApiInteractionVerificationWebauthnAuthenticationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiInteractionVerificationWebauthnAuthenticationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionVerificationWebauthnAuthenticationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/verification/webauthn-authentication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiInteractionVerificationWebauthnRegistrationPostRequest struct {
	ctx context.Context
	ApiService *InteractionAPIService
}

func (r ApiApiInteractionVerificationWebauthnRegistrationPostRequest) Execute() (*ApiInteractionVerificationWebauthnRegistrationPost200Response, *http.Response, error) {
	return r.ApiService.ApiInteractionVerificationWebauthnRegistrationPostExecute(r)
}

/*
ApiInteractionVerificationWebauthnRegistrationPost Method for ApiInteractionVerificationWebauthnRegistrationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiInteractionVerificationWebauthnRegistrationPostRequest
*/
func (a *InteractionAPIService) ApiInteractionVerificationWebauthnRegistrationPost(ctx context.Context) ApiApiInteractionVerificationWebauthnRegistrationPostRequest {
	return ApiApiInteractionVerificationWebauthnRegistrationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiInteractionVerificationWebauthnRegistrationPost200Response
func (a *InteractionAPIService) ApiInteractionVerificationWebauthnRegistrationPostExecute(r ApiApiInteractionVerificationWebauthnRegistrationPostRequest) (*ApiInteractionVerificationWebauthnRegistrationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiInteractionVerificationWebauthnRegistrationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.ApiInteractionVerificationWebauthnRegistrationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/interaction/verification/webauthn-registration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
