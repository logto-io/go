/*
Logto API references

API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.

API version: Cloud
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package logto

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// VerificationsAPIService VerificationsAPI service
type VerificationsAPIService service

type ApiCreateVerificationByPasswordRequest struct {
	ctx context.Context
	ApiService *VerificationsAPIService
	createVerificationByPasswordRequest *CreateVerificationByPasswordRequest
}

func (r ApiCreateVerificationByPasswordRequest) CreateVerificationByPasswordRequest(createVerificationByPasswordRequest CreateVerificationByPasswordRequest) ApiCreateVerificationByPasswordRequest {
	r.createVerificationByPasswordRequest = &createVerificationByPasswordRequest
	return r
}

func (r ApiCreateVerificationByPasswordRequest) Execute() (*CreateVerificationByPassword201Response, *http.Response, error) {
	return r.ApiService.CreateVerificationByPasswordExecute(r)
}

/*
CreateVerificationByPassword Create a record by password

Create a verification record by verifying the password.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVerificationByPasswordRequest
*/
func (a *VerificationsAPIService) CreateVerificationByPassword(ctx context.Context) ApiCreateVerificationByPasswordRequest {
	return ApiCreateVerificationByPasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateVerificationByPassword201Response
func (a *VerificationsAPIService) CreateVerificationByPasswordExecute(r ApiCreateVerificationByPasswordRequest) (*CreateVerificationByPassword201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVerificationByPassword201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerificationsAPIService.CreateVerificationByPassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/verifications/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVerificationByPasswordRequest == nil {
		return localVarReturnValue, nil, reportError("createVerificationByPasswordRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVerificationByPasswordRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVerificationBySocialRequest struct {
	ctx context.Context
	ApiService *VerificationsAPIService
	createVerificationBySocialRequest *CreateVerificationBySocialRequest
}

func (r ApiCreateVerificationBySocialRequest) CreateVerificationBySocialRequest(createVerificationBySocialRequest CreateVerificationBySocialRequest) ApiCreateVerificationBySocialRequest {
	r.createVerificationBySocialRequest = &createVerificationBySocialRequest
	return r
}

func (r ApiCreateVerificationBySocialRequest) Execute() (*CreateVerificationBySocial201Response, *http.Response, error) {
	return r.ApiService.CreateVerificationBySocialExecute(r)
}

/*
CreateVerificationBySocial Create a social verification record

Create a social verification record and return the authorization URI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVerificationBySocialRequest
*/
func (a *VerificationsAPIService) CreateVerificationBySocial(ctx context.Context) ApiCreateVerificationBySocialRequest {
	return ApiCreateVerificationBySocialRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateVerificationBySocial201Response
func (a *VerificationsAPIService) CreateVerificationBySocialExecute(r ApiCreateVerificationBySocialRequest) (*CreateVerificationBySocial201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVerificationBySocial201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerificationsAPIService.CreateVerificationBySocial")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/verifications/social"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVerificationBySocialRequest == nil {
		return localVarReturnValue, nil, reportError("createVerificationBySocialRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVerificationBySocialRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVerificationByVerificationCodeRequest struct {
	ctx context.Context
	ApiService *VerificationsAPIService
	createVerificationByVerificationCodeRequest *CreateVerificationByVerificationCodeRequest
}

func (r ApiCreateVerificationByVerificationCodeRequest) CreateVerificationByVerificationCodeRequest(createVerificationByVerificationCodeRequest CreateVerificationByVerificationCodeRequest) ApiCreateVerificationByVerificationCodeRequest {
	r.createVerificationByVerificationCodeRequest = &createVerificationByVerificationCodeRequest
	return r
}

func (r ApiCreateVerificationByVerificationCodeRequest) Execute() (*CreateVerificationByPassword201Response, *http.Response, error) {
	return r.ApiService.CreateVerificationByVerificationCodeExecute(r)
}

/*
CreateVerificationByVerificationCode Create a record by verification code

Create a verification record and send the code to the specified identifier. The code verification can be used to verify the given identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVerificationByVerificationCodeRequest
*/
func (a *VerificationsAPIService) CreateVerificationByVerificationCode(ctx context.Context) ApiCreateVerificationByVerificationCodeRequest {
	return ApiCreateVerificationByVerificationCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateVerificationByPassword201Response
func (a *VerificationsAPIService) CreateVerificationByVerificationCodeExecute(r ApiCreateVerificationByVerificationCodeRequest) (*CreateVerificationByPassword201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateVerificationByPassword201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerificationsAPIService.CreateVerificationByVerificationCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/verifications/verification-code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVerificationByVerificationCodeRequest == nil {
		return localVarReturnValue, nil, reportError("createVerificationByVerificationCodeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVerificationByVerificationCodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyVerificationBySocialRequest struct {
	ctx context.Context
	ApiService *VerificationsAPIService
	verifyVerificationBySocialRequest *VerifyVerificationBySocialRequest
}

func (r ApiVerifyVerificationBySocialRequest) VerifyVerificationBySocialRequest(verifyVerificationBySocialRequest VerifyVerificationBySocialRequest) ApiVerifyVerificationBySocialRequest {
	r.verifyVerificationBySocialRequest = &verifyVerificationBySocialRequest
	return r
}

func (r ApiVerifyVerificationBySocialRequest) Execute() (*VerifyVerificationByVerificationCode200Response, *http.Response, error) {
	return r.ApiService.VerifyVerificationBySocialExecute(r)
}

/*
VerifyVerificationBySocial Verify a social verification record

Verify a social verification record by callback connector data, and save the user information to the record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyVerificationBySocialRequest
*/
func (a *VerificationsAPIService) VerifyVerificationBySocial(ctx context.Context) ApiVerifyVerificationBySocialRequest {
	return ApiVerifyVerificationBySocialRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyVerificationByVerificationCode200Response
func (a *VerificationsAPIService) VerifyVerificationBySocialExecute(r ApiVerifyVerificationBySocialRequest) (*VerifyVerificationByVerificationCode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyVerificationByVerificationCode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerificationsAPIService.VerifyVerificationBySocial")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/verifications/social/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyVerificationBySocialRequest == nil {
		return localVarReturnValue, nil, reportError("verifyVerificationBySocialRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyVerificationBySocialRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyVerificationByVerificationCodeRequest struct {
	ctx context.Context
	ApiService *VerificationsAPIService
	verifyVerificationCodeVerificationRequest *VerifyVerificationCodeVerificationRequest
}

func (r ApiVerifyVerificationByVerificationCodeRequest) VerifyVerificationCodeVerificationRequest(verifyVerificationCodeVerificationRequest VerifyVerificationCodeVerificationRequest) ApiVerifyVerificationByVerificationCodeRequest {
	r.verifyVerificationCodeVerificationRequest = &verifyVerificationCodeVerificationRequest
	return r
}

func (r ApiVerifyVerificationByVerificationCodeRequest) Execute() (*VerifyVerificationByVerificationCode200Response, *http.Response, error) {
	return r.ApiService.VerifyVerificationByVerificationCodeExecute(r)
}

/*
VerifyVerificationByVerificationCode Verify verification code

Verify the provided verification code against the identifier. If successful, the verification record will be marked as verified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyVerificationByVerificationCodeRequest
*/
func (a *VerificationsAPIService) VerifyVerificationByVerificationCode(ctx context.Context) ApiVerifyVerificationByVerificationCodeRequest {
	return ApiVerifyVerificationByVerificationCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyVerificationByVerificationCode200Response
func (a *VerificationsAPIService) VerifyVerificationByVerificationCodeExecute(r ApiVerifyVerificationByVerificationCodeRequest) (*VerifyVerificationByVerificationCode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyVerificationByVerificationCode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerificationsAPIService.VerifyVerificationByVerificationCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/verifications/verification-code/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyVerificationCodeVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("verifyVerificationCodeVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyVerificationCodeVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
