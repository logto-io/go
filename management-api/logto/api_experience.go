/*
Logto API references

API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.

API version: Cloud
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package logto

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ExperienceAPIService ExperienceAPI service
type ExperienceAPIService service

type ApiAddUserProfileRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	addUserProfileRequest *AddUserProfileRequest
}

func (r ApiAddUserProfileRequest) AddUserProfileRequest(addUserProfileRequest AddUserProfileRequest) ApiAddUserProfileRequest {
	r.addUserProfileRequest = &addUserProfileRequest
	return r
}

func (r ApiAddUserProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddUserProfileExecute(r)
}

/*
AddUserProfile Add user profile

Adds user profile data to the current experience interaction. <br/>- For `Register`: The profile data provided before the identification request will be used to create a new user account. <br/>- For `SignIn` and `Register`: The profile data provided after the user is identified will be used to update the user's profile when the interaction is submitted. <br/>- `ForgotPassword`: Not supported.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddUserProfileRequest
*/
func (a *ExperienceAPIService) AddUserProfile(ctx context.Context) ApiAddUserProfileRequest {
	return ApiAddUserProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExperienceAPIService) AddUserProfileExecute(r ApiAddUserProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.AddUserProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addUserProfileRequest == nil {
		return nil, reportError("addUserProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addUserProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBindMfaVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	bindMfaVerificationRequest *BindMfaVerificationRequest
}

func (r ApiBindMfaVerificationRequest) BindMfaVerificationRequest(bindMfaVerificationRequest BindMfaVerificationRequest) ApiBindMfaVerificationRequest {
	r.bindMfaVerificationRequest = &bindMfaVerificationRequest
	return r
}

func (r ApiBindMfaVerificationRequest) Execute() (*http.Response, error) {
	return r.ApiService.BindMfaVerificationExecute(r)
}

/*
BindMfaVerification Bind MFA verification by verificationId

Bind new MFA verification to the user profile using the verificationId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBindMfaVerificationRequest
*/
func (a *ExperienceAPIService) BindMfaVerification(ctx context.Context) ApiBindMfaVerificationRequest {
	return ApiBindMfaVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExperienceAPIService) BindMfaVerificationExecute(r ApiBindMfaVerificationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.BindMfaVerification")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/profile/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bindMfaVerificationRequest == nil {
		return nil, reportError("bindMfaVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bindMfaVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateAndSendVerificationCodeRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	createAndSendVerificationCodeRequest *CreateAndSendVerificationCodeRequest
}

func (r ApiCreateAndSendVerificationCodeRequest) CreateAndSendVerificationCodeRequest(createAndSendVerificationCodeRequest CreateAndSendVerificationCodeRequest) ApiCreateAndSendVerificationCodeRequest {
	r.createAndSendVerificationCodeRequest = &createAndSendVerificationCodeRequest
	return r
}

func (r ApiCreateAndSendVerificationCodeRequest) Execute() (*CreateAndSendVerificationCode200Response, *http.Response, error) {
	return r.ApiService.CreateAndSendVerificationCodeExecute(r)
}

/*
CreateAndSendVerificationCode Create and send verification code

Create a new `CodeVerification` record and sends the code to the specified identifier. The code verification can be used to verify the given identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAndSendVerificationCodeRequest
*/
func (a *ExperienceAPIService) CreateAndSendVerificationCode(ctx context.Context) ApiCreateAndSendVerificationCodeRequest {
	return ApiCreateAndSendVerificationCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAndSendVerificationCode200Response
func (a *ExperienceAPIService) CreateAndSendVerificationCodeExecute(r ApiCreateAndSendVerificationCodeRequest) (*CreateAndSendVerificationCode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAndSendVerificationCode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.CreateAndSendVerificationCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/verification-code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAndSendVerificationCodeRequest == nil {
		return localVarReturnValue, nil, reportError("createAndSendVerificationCodeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAndSendVerificationCodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEnterpriseSsoVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	connectorId string
	createEnterpriseSsoVerificationRequest *CreateEnterpriseSsoVerificationRequest
}

func (r ApiCreateEnterpriseSsoVerificationRequest) CreateEnterpriseSsoVerificationRequest(createEnterpriseSsoVerificationRequest CreateEnterpriseSsoVerificationRequest) ApiCreateEnterpriseSsoVerificationRequest {
	r.createEnterpriseSsoVerificationRequest = &createEnterpriseSsoVerificationRequest
	return r
}

func (r ApiCreateEnterpriseSsoVerificationRequest) Execute() (*CreateEnterpriseSsoVerification200Response, *http.Response, error) {
	return r.ApiService.CreateEnterpriseSsoVerificationExecute(r)
}

/*
CreateEnterpriseSsoVerification Create enterprise SSO verification

Create a new EnterpriseSSO verification record and return the provider's authorization URI for the given connector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiCreateEnterpriseSsoVerificationRequest
*/
func (a *ExperienceAPIService) CreateEnterpriseSsoVerification(ctx context.Context, connectorId string) ApiCreateEnterpriseSsoVerificationRequest {
	return ApiCreateEnterpriseSsoVerificationRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
//  @return CreateEnterpriseSsoVerification200Response
func (a *ExperienceAPIService) CreateEnterpriseSsoVerificationExecute(r ApiCreateEnterpriseSsoVerificationRequest) (*CreateEnterpriseSsoVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateEnterpriseSsoVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.CreateEnterpriseSsoVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/sso/{connectorId}/authorization-uri"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createEnterpriseSsoVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("createEnterpriseSsoVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createEnterpriseSsoVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNewPasswordIdentityVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	createNewPasswordIdentityVerificationRequest *CreateNewPasswordIdentityVerificationRequest
}

func (r ApiCreateNewPasswordIdentityVerificationRequest) CreateNewPasswordIdentityVerificationRequest(createNewPasswordIdentityVerificationRequest CreateNewPasswordIdentityVerificationRequest) ApiCreateNewPasswordIdentityVerificationRequest {
	r.createNewPasswordIdentityVerificationRequest = &createNewPasswordIdentityVerificationRequest
	return r
}

func (r ApiCreateNewPasswordIdentityVerificationRequest) Execute() (*CreateNewPasswordIdentityVerification200Response, *http.Response, error) {
	return r.ApiService.CreateNewPasswordIdentityVerificationExecute(r)
}

/*
CreateNewPasswordIdentityVerification Create new password identity verification

Create a NewPasswordIdentity verification record for the new user registration use. The verification record includes a unique user identifier and a password that can be used to create a new user account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNewPasswordIdentityVerificationRequest
*/
func (a *ExperienceAPIService) CreateNewPasswordIdentityVerification(ctx context.Context) ApiCreateNewPasswordIdentityVerificationRequest {
	return ApiCreateNewPasswordIdentityVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateNewPasswordIdentityVerification200Response
func (a *ExperienceAPIService) CreateNewPasswordIdentityVerificationExecute(r ApiCreateNewPasswordIdentityVerificationRequest) (*CreateNewPasswordIdentityVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateNewPasswordIdentityVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.CreateNewPasswordIdentityVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/new-password-identity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createNewPasswordIdentityVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("createNewPasswordIdentityVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNewPasswordIdentityVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePasswordVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	createPasswordVerificationRequest *CreatePasswordVerificationRequest
}

func (r ApiCreatePasswordVerificationRequest) CreatePasswordVerificationRequest(createPasswordVerificationRequest CreatePasswordVerificationRequest) ApiCreatePasswordVerificationRequest {
	r.createPasswordVerificationRequest = &createPasswordVerificationRequest
	return r
}

func (r ApiCreatePasswordVerificationRequest) Execute() (*CreatePasswordVerification200Response, *http.Response, error) {
	return r.ApiService.CreatePasswordVerificationExecute(r)
}

/*
CreatePasswordVerification Create password verification record

Create and verify a new Password verification record. The verification record can only be created if the provided user credentials are correct.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePasswordVerificationRequest
*/
func (a *ExperienceAPIService) CreatePasswordVerification(ctx context.Context) ApiCreatePasswordVerificationRequest {
	return ApiCreatePasswordVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreatePasswordVerification200Response
func (a *ExperienceAPIService) CreatePasswordVerificationExecute(r ApiCreatePasswordVerificationRequest) (*CreatePasswordVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreatePasswordVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.CreatePasswordVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPasswordVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("createPasswordVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPasswordVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSocialVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	connectorId string
	createSocialVerificationRequest *CreateSocialVerificationRequest
}

func (r ApiCreateSocialVerificationRequest) CreateSocialVerificationRequest(createSocialVerificationRequest CreateSocialVerificationRequest) ApiCreateSocialVerificationRequest {
	r.createSocialVerificationRequest = &createSocialVerificationRequest
	return r
}

func (r ApiCreateSocialVerificationRequest) Execute() (*CreateSocialVerification200Response, *http.Response, error) {
	return r.ApiService.CreateSocialVerificationExecute(r)
}

/*
CreateSocialVerification Create social verification

Create a new SocialVerification record and return the provider's authorization URI for the given connector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiCreateSocialVerificationRequest
*/
func (a *ExperienceAPIService) CreateSocialVerification(ctx context.Context, connectorId string) ApiCreateSocialVerificationRequest {
	return ApiCreateSocialVerificationRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
//  @return CreateSocialVerification200Response
func (a *ExperienceAPIService) CreateSocialVerificationExecute(r ApiCreateSocialVerificationRequest) (*CreateSocialVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSocialVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.CreateSocialVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/social/{connectorId}/authorization-uri"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSocialVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("createSocialVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSocialVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTotpSecretRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
}

func (r ApiCreateTotpSecretRequest) Execute() (*CreateTotpSecret200Response, *http.Response, error) {
	return r.ApiService.CreateTotpSecretExecute(r)
}

/*
CreateTotpSecret Create TOTP secret

Create a new TOTP verification record and generate a new TOTP secret for the user. This secret can be used to bind a new TOTP verification to the user's profile. The verification record must be verified before the secret can be used to bind a new TOTP verification to the user's profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTotpSecretRequest
*/
func (a *ExperienceAPIService) CreateTotpSecret(ctx context.Context) ApiCreateTotpSecretRequest {
	return ApiCreateTotpSecretRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTotpSecret200Response
func (a *ExperienceAPIService) CreateTotpSecretExecute(r ApiCreateTotpSecretRequest) (*CreateTotpSecret200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTotpSecret200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.CreateTotpSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/totp/secret"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWebAuthnAuthenticationVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
}

func (r ApiCreateWebAuthnAuthenticationVerificationRequest) Execute() (*CreateWebAuthnAuthenticationVerification200Response, *http.Response, error) {
	return r.ApiService.CreateWebAuthnAuthenticationVerificationExecute(r)
}

/*
CreateWebAuthnAuthenticationVerification Create WebAuthn authentication verification

Create a new WebAuthn authentication verification record based on the user's existing WebAuthn credential. This verification record can be used to verify the user's WebAuthn credential.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWebAuthnAuthenticationVerificationRequest
*/
func (a *ExperienceAPIService) CreateWebAuthnAuthenticationVerification(ctx context.Context) ApiCreateWebAuthnAuthenticationVerificationRequest {
	return ApiCreateWebAuthnAuthenticationVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWebAuthnAuthenticationVerification200Response
func (a *ExperienceAPIService) CreateWebAuthnAuthenticationVerificationExecute(r ApiCreateWebAuthnAuthenticationVerificationRequest) (*CreateWebAuthnAuthenticationVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWebAuthnAuthenticationVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.CreateWebAuthnAuthenticationVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/web-authn/authentication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWebAuthnRegistrationVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
}

func (r ApiCreateWebAuthnRegistrationVerificationRequest) Execute() (*CreateWebAuthnRegistrationVerification200Response, *http.Response, error) {
	return r.ApiService.CreateWebAuthnRegistrationVerificationExecute(r)
}

/*
CreateWebAuthnRegistrationVerification Create WebAuthn registration verification

Create a new WebAuthn registration verification record. The verification record can be used to bind a new WebAuthn credential to the user's profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWebAuthnRegistrationVerificationRequest
*/
func (a *ExperienceAPIService) CreateWebAuthnRegistrationVerification(ctx context.Context) ApiCreateWebAuthnRegistrationVerificationRequest {
	return ApiCreateWebAuthnRegistrationVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateWebAuthnRegistrationVerification200Response
func (a *ExperienceAPIService) CreateWebAuthnRegistrationVerificationExecute(r ApiCreateWebAuthnRegistrationVerificationRequest) (*CreateWebAuthnRegistrationVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateWebAuthnRegistrationVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.CreateWebAuthnRegistrationVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/web-authn/registration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateBackupCodesRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
}

func (r ApiGenerateBackupCodesRequest) Execute() (*GenerateBackupCodes200Response, *http.Response, error) {
	return r.ApiService.GenerateBackupCodesExecute(r)
}

/*
GenerateBackupCodes Generate backup codes

Create a new BackupCode verification record with new backup codes generated. This verification record will be used to bind the backup codes to the user's profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateBackupCodesRequest
*/
func (a *ExperienceAPIService) GenerateBackupCodes(ctx context.Context) ApiGenerateBackupCodesRequest {
	return ApiGenerateBackupCodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateBackupCodes200Response
func (a *ExperienceAPIService) GenerateBackupCodesExecute(r ApiGenerateBackupCodesRequest) (*GenerateBackupCodes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateBackupCodes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.GenerateBackupCodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/backup-code/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEnabledSsoConnectorsRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	email *string
}

// The email address to find the enabled SSO connectors.
func (r ApiGetEnabledSsoConnectorsRequest) Email(email string) ApiGetEnabledSsoConnectorsRequest {
	r.email = &email
	return r
}

func (r ApiGetEnabledSsoConnectorsRequest) Execute() (*GetEnabledSsoConnectors200Response, *http.Response, error) {
	return r.ApiService.GetEnabledSsoConnectorsExecute(r)
}

/*
GetEnabledSsoConnectors Get enabled SSO connectors by the given email's domain

Extract the email domain from the provided email address. Returns all the enabled SSO connectors that match the email domain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEnabledSsoConnectorsRequest
*/
func (a *ExperienceAPIService) GetEnabledSsoConnectors(ctx context.Context) ApiGetEnabledSsoConnectorsRequest {
	return ApiGetEnabledSsoConnectorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEnabledSsoConnectors200Response
func (a *ExperienceAPIService) GetEnabledSsoConnectorsExecute(r ApiGetEnabledSsoConnectorsRequest) (*GetEnabledSsoConnectors200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEnabledSsoConnectors200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.GetEnabledSsoConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/sso-connectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIdentifyUserRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	identifyUserRequest *IdentifyUserRequest
}

func (r ApiIdentifyUserRequest) IdentifyUserRequest(identifyUserRequest IdentifyUserRequest) ApiIdentifyUserRequest {
	r.identifyUserRequest = &identifyUserRequest
	return r
}

func (r ApiIdentifyUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.IdentifyUserExecute(r)
}

/*
IdentifyUser Identify user for the current interaction

This API identifies the user based on the verificationId within the current experience interaction: <br/>- `SignIn` and `ForgotPassword` interactions: Verifies the user's identity using the provided `verificationId`. <br/>- `Register` interaction: Creates a new user account using the profile data from the current interaction. If a verificationId is provided, the profile data will first be updated with the verification record before creating the account. If not, the account is created directly from the stored profile data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIdentifyUserRequest
*/
func (a *ExperienceAPIService) IdentifyUser(ctx context.Context) ApiIdentifyUserRequest {
	return ApiIdentifyUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExperienceAPIService) IdentifyUserExecute(r ApiIdentifyUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.IdentifyUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/identification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.identifyUserRequest == nil {
		return nil, reportError("identifyUserRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifyUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInitInteractionRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	initInteractionRequest *InitInteractionRequest
}

func (r ApiInitInteractionRequest) InitInteractionRequest(initInteractionRequest InitInteractionRequest) ApiInitInteractionRequest {
	r.initInteractionRequest = &initInteractionRequest
	return r
}

func (r ApiInitInteractionRequest) Execute() (*http.Response, error) {
	return r.ApiService.InitInteractionExecute(r)
}

/*
InitInteraction Init new interaction

Init a new experience interaction with the given interaction type. Any existing interaction data will be cleared.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitInteractionRequest
*/
func (a *ExperienceAPIService) InitInteraction(ctx context.Context) ApiInitInteractionRequest {
	return ApiInitInteractionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExperienceAPIService) InitInteractionExecute(r ApiInitInteractionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.InitInteraction")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.initInteractionRequest == nil {
		return nil, reportError("initInteractionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.initInteractionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResetUserPasswordRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	resetUserPasswordRequest *ResetUserPasswordRequest
}

func (r ApiResetUserPasswordRequest) ResetUserPasswordRequest(resetUserPasswordRequest ResetUserPasswordRequest) ApiResetUserPasswordRequest {
	r.resetUserPasswordRequest = &resetUserPasswordRequest
	return r
}

func (r ApiResetUserPasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResetUserPasswordExecute(r)
}

/*
ResetUserPassword Reset user password

Reset the user's password. (`ForgotPassword` interaction only)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetUserPasswordRequest
*/
func (a *ExperienceAPIService) ResetUserPassword(ctx context.Context) ApiResetUserPasswordRequest {
	return ApiResetUserPasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExperienceAPIService) ResetUserPasswordExecute(r ApiResetUserPasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.ResetUserPassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/profile/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resetUserPasswordRequest == nil {
		return nil, reportError("resetUserPasswordRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resetUserPasswordRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSkipMfaBindingFlowRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
}

func (r ApiSkipMfaBindingFlowRequest) Execute() (*http.Response, error) {
	return r.ApiService.SkipMfaBindingFlowExecute(r)
}

/*
SkipMfaBindingFlow Skip MFA binding flow

Skip MFA verification binding flow. If the MFA is enabled in the sign-in experience settings and marked as `UserControlled`, the user can skip the MFA verification binding flow by calling this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSkipMfaBindingFlowRequest
*/
func (a *ExperienceAPIService) SkipMfaBindingFlow(ctx context.Context) ApiSkipMfaBindingFlowRequest {
	return ApiSkipMfaBindingFlowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExperienceAPIService) SkipMfaBindingFlowExecute(r ApiSkipMfaBindingFlowRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.SkipMfaBindingFlow")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/profile/mfa/mfa-skipped"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubmitInteractionRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
}

func (r ApiSubmitInteractionRequest) Execute() (*SubmitInteraction200Response, *http.Response, error) {
	return r.ApiService.SubmitInteractionExecute(r)
}

/*
SubmitInteraction Submit interaction

Submit the current interaction. <br/>- Submit the verified user identity to the OIDC provider for further authentication (SignIn and Register). <br/>- Update the user's profile data if any (SignIn and Register). <br/>- Reset the password and clear all the interaction records (ForgotPassword).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitInteractionRequest
*/
func (a *ExperienceAPIService) SubmitInteraction(ctx context.Context) ApiSubmitInteractionRequest {
	return ApiSubmitInteractionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitInteraction200Response
func (a *ExperienceAPIService) SubmitInteractionExecute(r ApiSubmitInteractionRequest) (*SubmitInteraction200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitInteraction200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.SubmitInteraction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInteractionEventRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	updateInteractionEventRequest *UpdateInteractionEventRequest
}

func (r ApiUpdateInteractionEventRequest) UpdateInteractionEventRequest(updateInteractionEventRequest UpdateInteractionEventRequest) ApiUpdateInteractionEventRequest {
	r.updateInteractionEventRequest = &updateInteractionEventRequest
	return r
}

func (r ApiUpdateInteractionEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateInteractionEventExecute(r)
}

/*
UpdateInteractionEvent Update interaction event

Update the current experience interaction event to the given event type. This API is used to switch the interaction event between `SignIn` and `Register`, while keeping all the verification records data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateInteractionEventRequest
*/
func (a *ExperienceAPIService) UpdateInteractionEvent(ctx context.Context) ApiUpdateInteractionEventRequest {
	return ApiUpdateInteractionEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ExperienceAPIService) UpdateInteractionEventExecute(r ApiUpdateInteractionEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.UpdateInteractionEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/interaction-event"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateInteractionEventRequest == nil {
		return nil, reportError("updateInteractionEventRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateInteractionEventRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVerifyBackupCodeRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	verifyBackupCodeRequest *VerifyBackupCodeRequest
}

func (r ApiVerifyBackupCodeRequest) VerifyBackupCodeRequest(verifyBackupCodeRequest VerifyBackupCodeRequest) ApiVerifyBackupCodeRequest {
	r.verifyBackupCodeRequest = &verifyBackupCodeRequest
	return r
}

func (r ApiVerifyBackupCodeRequest) Execute() (*VerifyBackupCode200Response, *http.Response, error) {
	return r.ApiService.VerifyBackupCodeExecute(r)
}

/*
VerifyBackupCode Verify backup code

Create a new BackupCode verification record and verify the provided backup code against the user's backup codes. The verification record will be marked as verified if the code is correct.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyBackupCodeRequest
*/
func (a *ExperienceAPIService) VerifyBackupCode(ctx context.Context) ApiVerifyBackupCodeRequest {
	return ApiVerifyBackupCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyBackupCode200Response
func (a *ExperienceAPIService) VerifyBackupCodeExecute(r ApiVerifyBackupCodeRequest) (*VerifyBackupCode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyBackupCode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.VerifyBackupCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/backup-code/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyBackupCodeRequest == nil {
		return localVarReturnValue, nil, reportError("verifyBackupCodeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyBackupCodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyEnterpriseSsoVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	connectorId string
	verifyEnterpriseSsoVerificationRequest *VerifyEnterpriseSsoVerificationRequest
}

func (r ApiVerifyEnterpriseSsoVerificationRequest) VerifyEnterpriseSsoVerificationRequest(verifyEnterpriseSsoVerificationRequest VerifyEnterpriseSsoVerificationRequest) ApiVerifyEnterpriseSsoVerificationRequest {
	r.verifyEnterpriseSsoVerificationRequest = &verifyEnterpriseSsoVerificationRequest
	return r
}

func (r ApiVerifyEnterpriseSsoVerificationRequest) Execute() (*VerifyEnterpriseSsoVerification200Response, *http.Response, error) {
	return r.ApiService.VerifyEnterpriseSsoVerificationExecute(r)
}

/*
VerifyEnterpriseSsoVerification Verify enterprise SSO verification

Verify the SSO authorization response data and get the user's identity from the SSO provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiVerifyEnterpriseSsoVerificationRequest
*/
func (a *ExperienceAPIService) VerifyEnterpriseSsoVerification(ctx context.Context, connectorId string) ApiVerifyEnterpriseSsoVerificationRequest {
	return ApiVerifyEnterpriseSsoVerificationRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
//  @return VerifyEnterpriseSsoVerification200Response
func (a *ExperienceAPIService) VerifyEnterpriseSsoVerificationExecute(r ApiVerifyEnterpriseSsoVerificationRequest) (*VerifyEnterpriseSsoVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyEnterpriseSsoVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.VerifyEnterpriseSsoVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/sso/{connectorId}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyEnterpriseSsoVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("verifyEnterpriseSsoVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyEnterpriseSsoVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifySocialVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	connectorId string
	verifySocialVerificationRequest *VerifySocialVerificationRequest
}

func (r ApiVerifySocialVerificationRequest) VerifySocialVerificationRequest(verifySocialVerificationRequest VerifySocialVerificationRequest) ApiVerifySocialVerificationRequest {
	r.verifySocialVerificationRequest = &verifySocialVerificationRequest
	return r
}

func (r ApiVerifySocialVerificationRequest) Execute() (*VerifySocialVerification200Response, *http.Response, error) {
	return r.ApiService.VerifySocialVerificationExecute(r)
}

/*
VerifySocialVerification Verify social verification

Verify the social authorization response data and get the user's identity data from the social provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiVerifySocialVerificationRequest
*/
func (a *ExperienceAPIService) VerifySocialVerification(ctx context.Context, connectorId string) ApiVerifySocialVerificationRequest {
	return ApiVerifySocialVerificationRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
//  @return VerifySocialVerification200Response
func (a *ExperienceAPIService) VerifySocialVerificationExecute(r ApiVerifySocialVerificationRequest) (*VerifySocialVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifySocialVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.VerifySocialVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/social/{connectorId}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifySocialVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("verifySocialVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifySocialVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyTotpVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	verifyTotpVerificationRequest *VerifyTotpVerificationRequest
}

func (r ApiVerifyTotpVerificationRequest) VerifyTotpVerificationRequest(verifyTotpVerificationRequest VerifyTotpVerificationRequest) ApiVerifyTotpVerificationRequest {
	r.verifyTotpVerificationRequest = &verifyTotpVerificationRequest
	return r
}

func (r ApiVerifyTotpVerificationRequest) Execute() (*VerifyTotpVerification200Response, *http.Response, error) {
	return r.ApiService.VerifyTotpVerificationExecute(r)
}

/*
VerifyTotpVerification Verify TOTP verification

Verifies the provided TOTP code against the new created TOTP secret or the existing TOTP secret. If a verificationId is provided, this API will verify the code against the TOTP secret that is associated with the verification record. Otherwise, a new TOTP verification record will be created and verified against the user's existing TOTP secret.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyTotpVerificationRequest
*/
func (a *ExperienceAPIService) VerifyTotpVerification(ctx context.Context) ApiVerifyTotpVerificationRequest {
	return ApiVerifyTotpVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyTotpVerification200Response
func (a *ExperienceAPIService) VerifyTotpVerificationExecute(r ApiVerifyTotpVerificationRequest) (*VerifyTotpVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyTotpVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.VerifyTotpVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/totp/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyTotpVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("verifyTotpVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyTotpVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyVerificationCodeVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	verifyVerificationCodeVerificationRequest *VerifyVerificationCodeVerificationRequest
}

func (r ApiVerifyVerificationCodeVerificationRequest) VerifyVerificationCodeVerificationRequest(verifyVerificationCodeVerificationRequest VerifyVerificationCodeVerificationRequest) ApiVerifyVerificationCodeVerificationRequest {
	r.verifyVerificationCodeVerificationRequest = &verifyVerificationCodeVerificationRequest
	return r
}

func (r ApiVerifyVerificationCodeVerificationRequest) Execute() (*VerifyVerificationCodeVerification200Response, *http.Response, error) {
	return r.ApiService.VerifyVerificationCodeVerificationExecute(r)
}

/*
VerifyVerificationCodeVerification Verify verification code

Verify the provided verification code against the user's identifier. If successful, the verification record will be marked as verified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyVerificationCodeVerificationRequest
*/
func (a *ExperienceAPIService) VerifyVerificationCodeVerification(ctx context.Context) ApiVerifyVerificationCodeVerificationRequest {
	return ApiVerifyVerificationCodeVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyVerificationCodeVerification200Response
func (a *ExperienceAPIService) VerifyVerificationCodeVerificationExecute(r ApiVerifyVerificationCodeVerificationRequest) (*VerifyVerificationCodeVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyVerificationCodeVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.VerifyVerificationCodeVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/verification-code/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyVerificationCodeVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("verifyVerificationCodeVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyVerificationCodeVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyWebAuthnAuthenticationVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	verifyWebAuthnAuthenticationVerificationRequest *VerifyWebAuthnAuthenticationVerificationRequest
}

func (r ApiVerifyWebAuthnAuthenticationVerificationRequest) VerifyWebAuthnAuthenticationVerificationRequest(verifyWebAuthnAuthenticationVerificationRequest VerifyWebAuthnAuthenticationVerificationRequest) ApiVerifyWebAuthnAuthenticationVerificationRequest {
	r.verifyWebAuthnAuthenticationVerificationRequest = &verifyWebAuthnAuthenticationVerificationRequest
	return r
}

func (r ApiVerifyWebAuthnAuthenticationVerificationRequest) Execute() (*VerifyWebAuthnAuthenticationVerification200Response, *http.Response, error) {
	return r.ApiService.VerifyWebAuthnAuthenticationVerificationExecute(r)
}

/*
VerifyWebAuthnAuthenticationVerification Verify WebAuthn authentication verification

Verifies the WebAuthn authentication response against the user's authentication challenge. Upon successful verification, the verification record will be marked as verified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyWebAuthnAuthenticationVerificationRequest
*/
func (a *ExperienceAPIService) VerifyWebAuthnAuthenticationVerification(ctx context.Context) ApiVerifyWebAuthnAuthenticationVerificationRequest {
	return ApiVerifyWebAuthnAuthenticationVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyWebAuthnAuthenticationVerification200Response
func (a *ExperienceAPIService) VerifyWebAuthnAuthenticationVerificationExecute(r ApiVerifyWebAuthnAuthenticationVerificationRequest) (*VerifyWebAuthnAuthenticationVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyWebAuthnAuthenticationVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.VerifyWebAuthnAuthenticationVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/web-authn/authentication/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyWebAuthnAuthenticationVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("verifyWebAuthnAuthenticationVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyWebAuthnAuthenticationVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyWebAuthnRegistrationVerificationRequest struct {
	ctx context.Context
	ApiService *ExperienceAPIService
	verifyWebAuthnRegistrationVerificationRequest *VerifyWebAuthnRegistrationVerificationRequest
}

func (r ApiVerifyWebAuthnRegistrationVerificationRequest) VerifyWebAuthnRegistrationVerificationRequest(verifyWebAuthnRegistrationVerificationRequest VerifyWebAuthnRegistrationVerificationRequest) ApiVerifyWebAuthnRegistrationVerificationRequest {
	r.verifyWebAuthnRegistrationVerificationRequest = &verifyWebAuthnRegistrationVerificationRequest
	return r
}

func (r ApiVerifyWebAuthnRegistrationVerificationRequest) Execute() (*VerifyWebAuthnRegistrationVerification200Response, *http.Response, error) {
	return r.ApiService.VerifyWebAuthnRegistrationVerificationExecute(r)
}

/*
VerifyWebAuthnRegistrationVerification Verify WebAuthn registration verification

Verify the WebAuthn registration response against the user's WebAuthn registration challenge. If the response is valid, the WebAuthn registration record will be marked as verified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyWebAuthnRegistrationVerificationRequest
*/
func (a *ExperienceAPIService) VerifyWebAuthnRegistrationVerification(ctx context.Context) ApiVerifyWebAuthnRegistrationVerificationRequest {
	return ApiVerifyWebAuthnRegistrationVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyWebAuthnRegistrationVerification200Response
func (a *ExperienceAPIService) VerifyWebAuthnRegistrationVerificationExecute(r ApiVerifyWebAuthnRegistrationVerificationRequest) (*VerifyWebAuthnRegistrationVerification200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyWebAuthnRegistrationVerification200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExperienceAPIService.VerifyWebAuthnRegistrationVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/experience/verification/web-authn/registration/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.verifyWebAuthnRegistrationVerificationRequest == nil {
		return localVarReturnValue, nil, reportError("verifyWebAuthnRegistrationVerificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.verifyWebAuthnRegistrationVerificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
