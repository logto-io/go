/*
Logto API references

API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.

API version: Cloud
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package logto

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ApplicationsAPIService ApplicationsAPI service
type ApplicationsAPIService service

type ApiAssignApplicationRolesRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
	assignApplicationRolesRequest *AssignApplicationRolesRequest
}

func (r ApiAssignApplicationRolesRequest) AssignApplicationRolesRequest(assignApplicationRolesRequest AssignApplicationRolesRequest) ApiAssignApplicationRolesRequest {
	r.assignApplicationRolesRequest = &assignApplicationRolesRequest
	return r
}

func (r ApiAssignApplicationRolesRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssignApplicationRolesExecute(r)
}

/*
AssignApplicationRoles Assign API resource roles to application

Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @return ApiAssignApplicationRolesRequest
*/
func (a *ApplicationsAPIService) AssignApplicationRoles(ctx context.Context, applicationId string) ApiAssignApplicationRolesRequest {
	return ApiAssignApplicationRolesRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) AssignApplicationRolesExecute(r ApiAssignApplicationRolesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.AssignApplicationRoles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assignApplicationRolesRequest == nil {
		return nil, reportError("assignApplicationRolesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assignApplicationRolesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateApplicationRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	createApplicationRequest *CreateApplicationRequest
}

func (r ApiCreateApplicationRequest) CreateApplicationRequest(createApplicationRequest CreateApplicationRequest) ApiCreateApplicationRequest {
	r.createApplicationRequest = &createApplicationRequest
	return r
}

func (r ApiCreateApplicationRequest) Execute() (*ListApplications200ResponseInner, *http.Response, error) {
	return r.ApiService.CreateApplicationExecute(r)
}

/*
CreateApplication Create an application

Create a new application with the given data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApplicationRequest
*/
func (a *ApplicationsAPIService) CreateApplication(ctx context.Context) ApiCreateApplicationRequest {
	return ApiCreateApplicationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListApplications200ResponseInner
func (a *ApplicationsAPIService) CreateApplicationExecute(r ApiCreateApplicationRequest) (*ListApplications200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListApplications200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createApplicationRequest == nil {
		return localVarReturnValue, nil, reportError("createApplicationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createApplicationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationProtectedAppMetadataCustomDomainRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	createApplicationProtectedAppMetadataCustomDomainRequest *CreateApplicationProtectedAppMetadataCustomDomainRequest
}

func (r ApiCreateApplicationProtectedAppMetadataCustomDomainRequest) CreateApplicationProtectedAppMetadataCustomDomainRequest(createApplicationProtectedAppMetadataCustomDomainRequest CreateApplicationProtectedAppMetadataCustomDomainRequest) ApiCreateApplicationProtectedAppMetadataCustomDomainRequest {
	r.createApplicationProtectedAppMetadataCustomDomainRequest = &createApplicationProtectedAppMetadataCustomDomainRequest
	return r
}

func (r ApiCreateApplicationProtectedAppMetadataCustomDomainRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateApplicationProtectedAppMetadataCustomDomainExecute(r)
}

/*
CreateApplicationProtectedAppMetadataCustomDomain Add a custom domain to the application.

Add a custom domain to the application. You'll need to setup DNS record later.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiCreateApplicationProtectedAppMetadataCustomDomainRequest
*/
func (a *ApplicationsAPIService) CreateApplicationProtectedAppMetadataCustomDomain(ctx context.Context, id string) ApiCreateApplicationProtectedAppMetadataCustomDomainRequest {
	return ApiCreateApplicationProtectedAppMetadataCustomDomainRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) CreateApplicationProtectedAppMetadataCustomDomainExecute(r ApiCreateApplicationProtectedAppMetadataCustomDomainRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationProtectedAppMetadataCustomDomain")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/protected-app-metadata/custom-domains"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createApplicationProtectedAppMetadataCustomDomainRequest == nil {
		return nil, reportError("createApplicationProtectedAppMetadataCustomDomainRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createApplicationProtectedAppMetadataCustomDomainRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateApplicationSecretRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	createApplicationSecretRequest *CreateApplicationSecretRequest
}

func (r ApiCreateApplicationSecretRequest) CreateApplicationSecretRequest(createApplicationSecretRequest CreateApplicationSecretRequest) ApiCreateApplicationSecretRequest {
	r.createApplicationSecretRequest = &createApplicationSecretRequest
	return r
}

func (r ApiCreateApplicationSecretRequest) Execute() (*ListApplicationSecrets200ResponseInner, *http.Response, error) {
	return r.ApiService.CreateApplicationSecretExecute(r)
}

/*
CreateApplicationSecret Add application secret

Add a new secret for the application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiCreateApplicationSecretRequest
*/
func (a *ApplicationsAPIService) CreateApplicationSecret(ctx context.Context, id string) ApiCreateApplicationSecretRequest {
	return ApiCreateApplicationSecretRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListApplicationSecrets200ResponseInner
func (a *ApplicationsAPIService) CreateApplicationSecretExecute(r ApiCreateApplicationSecretRequest) (*ListApplicationSecrets200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListApplicationSecrets200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createApplicationSecretRequest == nil {
		return localVarReturnValue, nil, reportError("createApplicationSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createApplicationSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationUserConsentOrganizationRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	userId string
	createApplicationUserConsentOrganizationRequest *CreateApplicationUserConsentOrganizationRequest
}

func (r ApiCreateApplicationUserConsentOrganizationRequest) CreateApplicationUserConsentOrganizationRequest(createApplicationUserConsentOrganizationRequest CreateApplicationUserConsentOrganizationRequest) ApiCreateApplicationUserConsentOrganizationRequest {
	r.createApplicationUserConsentOrganizationRequest = &createApplicationUserConsentOrganizationRequest
	return r
}

func (r ApiCreateApplicationUserConsentOrganizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateApplicationUserConsentOrganizationExecute(r)
}

/*
CreateApplicationUserConsentOrganization Grant a list of organization access of a user for a application.

Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations' access by default.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @param userId The unique identifier of the user.
 @return ApiCreateApplicationUserConsentOrganizationRequest
*/
func (a *ApplicationsAPIService) CreateApplicationUserConsentOrganization(ctx context.Context, id string, userId string) ApiCreateApplicationUserConsentOrganizationRequest {
	return ApiCreateApplicationUserConsentOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) CreateApplicationUserConsentOrganizationExecute(r ApiCreateApplicationUserConsentOrganizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationUserConsentOrganization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/users/{userId}/consent-organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createApplicationUserConsentOrganizationRequest == nil {
		return nil, reportError("createApplicationUserConsentOrganizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createApplicationUserConsentOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateApplicationUserConsentScopeRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
	createApplicationUserConsentScopeRequest *CreateApplicationUserConsentScopeRequest
}

func (r ApiCreateApplicationUserConsentScopeRequest) CreateApplicationUserConsentScopeRequest(createApplicationUserConsentScopeRequest CreateApplicationUserConsentScopeRequest) ApiCreateApplicationUserConsentScopeRequest {
	r.createApplicationUserConsentScopeRequest = &createApplicationUserConsentScopeRequest
	return r
}

func (r ApiCreateApplicationUserConsentScopeRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateApplicationUserConsentScopeExecute(r)
}

/*
CreateApplicationUserConsentScope Assign user consent scopes to application.

Assign the user consent scopes to an application by application id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @return ApiCreateApplicationUserConsentScopeRequest
*/
func (a *ApplicationsAPIService) CreateApplicationUserConsentScope(ctx context.Context, applicationId string) ApiCreateApplicationUserConsentScopeRequest {
	return ApiCreateApplicationUserConsentScopeRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) CreateApplicationUserConsentScopeExecute(r ApiCreateApplicationUserConsentScopeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationUserConsentScope")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/user-consent-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createApplicationUserConsentScopeRequest == nil {
		return nil, reportError("createApplicationUserConsentScopeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createApplicationUserConsentScopeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
}

func (r ApiDeleteApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationExecute(r)
}

/*
DeleteApplication Delete application

Delete application by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiDeleteApplicationRequest
*/
func (a *ApplicationsAPIService) DeleteApplication(ctx context.Context, id string) ApiDeleteApplicationRequest {
	return ApiDeleteApplicationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationExecute(r ApiDeleteApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationLegacySecretRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
}

func (r ApiDeleteApplicationLegacySecretRequest) Execute() (*DeleteApplicationLegacySecret200Response, *http.Response, error) {
	return r.ApiService.DeleteApplicationLegacySecretExecute(r)
}

/*
DeleteApplicationLegacySecret Delete application legacy secret

Delete the legacy secret for the application and replace it with a new internal secret.

Note: This operation does not "really" delete the legacy secret because it is still needed for internal validation. We may remove the display of the legacy secret (the `secret` field in the application response) in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiDeleteApplicationLegacySecretRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationLegacySecret(ctx context.Context, id string) ApiDeleteApplicationLegacySecretRequest {
	return ApiDeleteApplicationLegacySecretRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeleteApplicationLegacySecret200Response
func (a *ApplicationsAPIService) DeleteApplicationLegacySecretExecute(r ApiDeleteApplicationLegacySecretRequest) (*DeleteApplicationLegacySecret200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteApplicationLegacySecret200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationLegacySecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/legacy-secret"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApplicationProtectedAppMetadataCustomDomainRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	domain string
}

func (r ApiDeleteApplicationProtectedAppMetadataCustomDomainRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationProtectedAppMetadataCustomDomainExecute(r)
}

/*
DeleteApplicationProtectedAppMetadataCustomDomain Remove custom domain.

Remove custom domain from the specified application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @param domain
 @return ApiDeleteApplicationProtectedAppMetadataCustomDomainRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationProtectedAppMetadataCustomDomain(ctx context.Context, id string, domain string) ApiDeleteApplicationProtectedAppMetadataCustomDomainRequest {
	return ApiDeleteApplicationProtectedAppMetadataCustomDomainRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		domain: domain,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationProtectedAppMetadataCustomDomainExecute(r ApiDeleteApplicationProtectedAppMetadataCustomDomainRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationProtectedAppMetadataCustomDomain")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/protected-app-metadata/custom-domains/{domain}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domain"+"}", url.PathEscape(parameterValueToString(r.domain, "domain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationRoleRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
	roleId string
}

func (r ApiDeleteApplicationRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationRoleExecute(r)
}

/*
DeleteApplicationRole Remove a API resource role from application

Remove a API resource role from the specified application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @param roleId The unique identifier of the role.
 @return ApiDeleteApplicationRoleRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationRole(ctx context.Context, applicationId string, roleId string) ApiDeleteApplicationRoleRequest {
	return ApiDeleteApplicationRoleRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		roleId: roleId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationRoleExecute(r ApiDeleteApplicationRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/roles/{roleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", url.PathEscape(parameterValueToString(r.roleId, "roleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationSecretRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	name string
}

func (r ApiDeleteApplicationSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationSecretExecute(r)
}

/*
DeleteApplicationSecret Delete application secret

Delete a secret for the application by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @param name The name of the secret.
 @return ApiDeleteApplicationSecretRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationSecret(ctx context.Context, id string, name string) ApiDeleteApplicationSecretRequest {
	return ApiDeleteApplicationSecretRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		name: name,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationSecretExecute(r ApiDeleteApplicationSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/secrets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationUserConsentOrganizationRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	userId string
	organizationId string
}

func (r ApiDeleteApplicationUserConsentOrganizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationUserConsentOrganizationExecute(r)
}

/*
DeleteApplicationUserConsentOrganization Revoke a user's access to an organization for a application.

Revoke a user's access to an organization for a application by application id, user id and organization id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @param userId The unique identifier of the user.
 @param organizationId The unique identifier of the organization.
 @return ApiDeleteApplicationUserConsentOrganizationRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationUserConsentOrganization(ctx context.Context, id string, userId string, organizationId string) ApiDeleteApplicationUserConsentOrganizationRequest {
	return ApiDeleteApplicationUserConsentOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationUserConsentOrganizationExecute(r ApiDeleteApplicationUserConsentOrganizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationUserConsentOrganization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/users/{userId}/consent-organizations/{organizationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationUserConsentScopeRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
	scopeType string
	scopeId string
}

func (r ApiDeleteApplicationUserConsentScopeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationUserConsentScopeExecute(r)
}

/*
DeleteApplicationUserConsentScope Remove user consent scope from application.

Remove the user consent scope from an application by application id, scope type and scope id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @param scopeType
 @param scopeId The unique identifier of the scope.
 @return ApiDeleteApplicationUserConsentScopeRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationUserConsentScope(ctx context.Context, applicationId string, scopeType string, scopeId string) ApiDeleteApplicationUserConsentScopeRequest {
	return ApiDeleteApplicationUserConsentScopeRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		scopeType: scopeType,
		scopeId: scopeId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationUserConsentScopeExecute(r ApiDeleteApplicationUserConsentScopeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationUserConsentScope")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/user-consent-scopes/{scopeType}/{scopeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scopeType"+"}", url.PathEscape(parameterValueToString(r.scopeType, "scopeType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scopeId"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetApplicationRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
}

func (r ApiGetApplicationRequest) Execute() (*GetApplication200Response, *http.Response, error) {
	return r.ApiService.GetApplicationExecute(r)
}

/*
GetApplication Get application

Get application details by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiGetApplicationRequest
*/
func (a *ApplicationsAPIService) GetApplication(ctx context.Context, id string) ApiGetApplicationRequest {
	return ApiGetApplicationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetApplication200Response
func (a *ApplicationsAPIService) GetApplicationExecute(r ApiGetApplicationRequest) (*GetApplication200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetApplication200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationSignInExperienceRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
}

func (r ApiGetApplicationSignInExperienceRequest) Execute() (*GetApplicationSignInExperience200Response, *http.Response, error) {
	return r.ApiService.GetApplicationSignInExperienceExecute(r)
}

/*
GetApplicationSignInExperience Get the application level sign-in experience

Get application level sign-in experience for a given application. 
 - Only branding properties and terms links customization is supported for now. 

 - Only third-party applications can have the sign-in experience customization for now.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @return ApiGetApplicationSignInExperienceRequest
*/
func (a *ApplicationsAPIService) GetApplicationSignInExperience(ctx context.Context, applicationId string) ApiGetApplicationSignInExperienceRequest {
	return ApiGetApplicationSignInExperienceRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return GetApplicationSignInExperience200Response
func (a *ApplicationsAPIService) GetApplicationSignInExperienceExecute(r ApiGetApplicationSignInExperienceRequest) (*GetApplicationSignInExperience200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetApplicationSignInExperience200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetApplicationSignInExperience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/sign-in-experience"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationOrganizationsRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	page *int32
	pageSize *int32
}

// Page number (starts from 1).
func (r ApiListApplicationOrganizationsRequest) Page(page int32) ApiListApplicationOrganizationsRequest {
	r.page = &page
	return r
}

// Entries per page.
func (r ApiListApplicationOrganizationsRequest) PageSize(pageSize int32) ApiListApplicationOrganizationsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListApplicationOrganizationsRequest) Execute() ([]ListApplicationOrganizations200ResponseInner, *http.Response, error) {
	return r.ApiService.ListApplicationOrganizationsExecute(r)
}

/*
ListApplicationOrganizations Get application organizations

Get the list of organizations that an application is associated with.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiListApplicationOrganizationsRequest
*/
func (a *ApplicationsAPIService) ListApplicationOrganizations(ctx context.Context, id string) ApiListApplicationOrganizationsRequest {
	return ApiListApplicationOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ListApplicationOrganizations200ResponseInner
func (a *ApplicationsAPIService) ListApplicationOrganizationsExecute(r ApiListApplicationOrganizationsRequest) ([]ListApplicationOrganizations200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListApplicationOrganizations200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplicationOrganizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationProtectedAppMetadataCustomDomainsRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
}

func (r ApiListApplicationProtectedAppMetadataCustomDomainsRequest) Execute() ([]ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner, *http.Response, error) {
	return r.ApiService.ListApplicationProtectedAppMetadataCustomDomainsExecute(r)
}

/*
ListApplicationProtectedAppMetadataCustomDomains Get application custom domains.

Get custom domains of the specified application, the application type should be protected app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiListApplicationProtectedAppMetadataCustomDomainsRequest
*/
func (a *ApplicationsAPIService) ListApplicationProtectedAppMetadataCustomDomains(ctx context.Context, id string) ApiListApplicationProtectedAppMetadataCustomDomainsRequest {
	return ApiListApplicationProtectedAppMetadataCustomDomainsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner
func (a *ApplicationsAPIService) ListApplicationProtectedAppMetadataCustomDomainsExecute(r ApiListApplicationProtectedAppMetadataCustomDomainsRequest) ([]ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplicationProtectedAppMetadataCustomDomains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/protected-app-metadata/custom-domains"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationRolesRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
	page *int32
	pageSize *int32
	searchParams *map[string]string
}

// Page number (starts from 1).
func (r ApiListApplicationRolesRequest) Page(page int32) ApiListApplicationRolesRequest {
	r.page = &page
	return r
}

// Entries per page.
func (r ApiListApplicationRolesRequest) PageSize(pageSize int32) ApiListApplicationRolesRequest {
	r.pageSize = &pageSize
	return r
}

// Search query parameters.
func (r ApiListApplicationRolesRequest) SearchParams(searchParams map[string]string) ApiListApplicationRolesRequest {
	r.searchParams = &searchParams
	return r
}

func (r ApiListApplicationRolesRequest) Execute() ([]ListApplicationRoles200ResponseInner, *http.Response, error) {
	return r.ApiService.ListApplicationRolesExecute(r)
}

/*
ListApplicationRoles Get application API resource roles

Get API resource roles assigned to the specified application with pagination.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @return ApiListApplicationRolesRequest
*/
func (a *ApplicationsAPIService) ListApplicationRoles(ctx context.Context, applicationId string) ApiListApplicationRolesRequest {
	return ApiListApplicationRolesRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return []ListApplicationRoles200ResponseInner
func (a *ApplicationsAPIService) ListApplicationRolesExecute(r ApiListApplicationRolesRequest) ([]ListApplicationRoles200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListApplicationRoles200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplicationRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.searchParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_params", r.searchParams, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationSecretsRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
}

func (r ApiListApplicationSecretsRequest) Execute() ([]ListApplicationSecrets200ResponseInner, *http.Response, error) {
	return r.ApiService.ListApplicationSecretsExecute(r)
}

/*
ListApplicationSecrets Get application secrets

Get all the secrets for the application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiListApplicationSecretsRequest
*/
func (a *ApplicationsAPIService) ListApplicationSecrets(ctx context.Context, id string) ApiListApplicationSecretsRequest {
	return ApiListApplicationSecretsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ListApplicationSecrets200ResponseInner
func (a *ApplicationsAPIService) ListApplicationSecretsExecute(r ApiListApplicationSecretsRequest) ([]ListApplicationSecrets200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListApplicationSecrets200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplicationSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationUserConsentOrganizationsRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	userId string
	page *int32
	pageSize *int32
}

// Page number (starts from 1).
func (r ApiListApplicationUserConsentOrganizationsRequest) Page(page int32) ApiListApplicationUserConsentOrganizationsRequest {
	r.page = &page
	return r
}

// Entries per page.
func (r ApiListApplicationUserConsentOrganizationsRequest) PageSize(pageSize int32) ApiListApplicationUserConsentOrganizationsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListApplicationUserConsentOrganizationsRequest) Execute() (*ListApplicationUserConsentOrganizations200Response, *http.Response, error) {
	return r.ApiService.ListApplicationUserConsentOrganizationsExecute(r)
}

/*
ListApplicationUserConsentOrganizations List all the user consented organizations of a application.

List all the user consented organizations for a application by application id and user id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @param userId The unique identifier of the user.
 @return ApiListApplicationUserConsentOrganizationsRequest
*/
func (a *ApplicationsAPIService) ListApplicationUserConsentOrganizations(ctx context.Context, id string, userId string) ApiListApplicationUserConsentOrganizationsRequest {
	return ApiListApplicationUserConsentOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
//  @return ListApplicationUserConsentOrganizations200Response
func (a *ApplicationsAPIService) ListApplicationUserConsentOrganizationsExecute(r ApiListApplicationUserConsentOrganizationsRequest) (*ListApplicationUserConsentOrganizations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListApplicationUserConsentOrganizations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplicationUserConsentOrganizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/users/{userId}/consent-organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationUserConsentScopesRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
}

func (r ApiListApplicationUserConsentScopesRequest) Execute() (*ListApplicationUserConsentScopes200Response, *http.Response, error) {
	return r.ApiService.ListApplicationUserConsentScopesExecute(r)
}

/*
ListApplicationUserConsentScopes List all the user consent scopes of an application.

List all the user consent scopes of an application by application id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @return ApiListApplicationUserConsentScopesRequest
*/
func (a *ApplicationsAPIService) ListApplicationUserConsentScopes(ctx context.Context, applicationId string) ApiListApplicationUserConsentScopesRequest {
	return ApiListApplicationUserConsentScopesRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return ListApplicationUserConsentScopes200Response
func (a *ApplicationsAPIService) ListApplicationUserConsentScopesExecute(r ApiListApplicationUserConsentScopesRequest) (*ListApplicationUserConsentScopes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListApplicationUserConsentScopes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplicationUserConsentScopes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/user-consent-scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationsRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	types *ListApplicationsTypesParameter
	excludeRoleId *string
	excludeOrganizationId *string
	isThirdParty *ListApplicationsIsThirdPartyParameter
	page *int32
	pageSize *int32
	searchParams *map[string]string
}

// An array of application types to filter applications.
func (r ApiListApplicationsRequest) Types(types ListApplicationsTypesParameter) ApiListApplicationsRequest {
	r.types = &types
	return r
}

func (r ApiListApplicationsRequest) ExcludeRoleId(excludeRoleId string) ApiListApplicationsRequest {
	r.excludeRoleId = &excludeRoleId
	return r
}

func (r ApiListApplicationsRequest) ExcludeOrganizationId(excludeOrganizationId string) ApiListApplicationsRequest {
	r.excludeOrganizationId = &excludeOrganizationId
	return r
}

func (r ApiListApplicationsRequest) IsThirdParty(isThirdParty ListApplicationsIsThirdPartyParameter) ApiListApplicationsRequest {
	r.isThirdParty = &isThirdParty
	return r
}

// Page number (starts from 1).
func (r ApiListApplicationsRequest) Page(page int32) ApiListApplicationsRequest {
	r.page = &page
	return r
}

// Entries per page.
func (r ApiListApplicationsRequest) PageSize(pageSize int32) ApiListApplicationsRequest {
	r.pageSize = &pageSize
	return r
}

// Search query parameters.
func (r ApiListApplicationsRequest) SearchParams(searchParams map[string]string) ApiListApplicationsRequest {
	r.searchParams = &searchParams
	return r
}

func (r ApiListApplicationsRequest) Execute() ([]ListApplications200ResponseInner, *http.Response, error) {
	return r.ApiService.ListApplicationsExecute(r)
}

/*
ListApplications Get applications

Get applications that match the given query with pagination.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListApplicationsRequest
*/
func (a *ApplicationsAPIService) ListApplications(ctx context.Context) ApiListApplicationsRequest {
	return ApiListApplicationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListApplications200ResponseInner
func (a *ApplicationsAPIService) ListApplicationsExecute(r ApiListApplicationsRequest) ([]ListApplications200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListApplications200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	if r.excludeRoleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRoleId", r.excludeRoleId, "form", "")
	}
	if r.excludeOrganizationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeOrganizationId", r.excludeOrganizationId, "form", "")
	}
	if r.isThirdParty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isThirdParty", r.isThirdParty, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.searchParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_params", r.searchParams, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceApplicationRolesRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
	replaceApplicationRolesRequest *ReplaceApplicationRolesRequest
}

func (r ApiReplaceApplicationRolesRequest) ReplaceApplicationRolesRequest(replaceApplicationRolesRequest ReplaceApplicationRolesRequest) ApiReplaceApplicationRolesRequest {
	r.replaceApplicationRolesRequest = &replaceApplicationRolesRequest
	return r
}

func (r ApiReplaceApplicationRolesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReplaceApplicationRolesExecute(r)
}

/*
ReplaceApplicationRoles Update API resource roles for application

Update API resource roles assigned to the specified application. This will replace the existing API resource roles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @return ApiReplaceApplicationRolesRequest
*/
func (a *ApplicationsAPIService) ReplaceApplicationRoles(ctx context.Context, applicationId string) ApiReplaceApplicationRolesRequest {
	return ApiReplaceApplicationRolesRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ReplaceApplicationRolesExecute(r ApiReplaceApplicationRolesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ReplaceApplicationRoles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.replaceApplicationRolesRequest == nil {
		return nil, reportError("replaceApplicationRolesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.replaceApplicationRolesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReplaceApplicationSignInExperienceRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
	replaceApplicationSignInExperienceRequest *ReplaceApplicationSignInExperienceRequest
}

func (r ApiReplaceApplicationSignInExperienceRequest) ReplaceApplicationSignInExperienceRequest(replaceApplicationSignInExperienceRequest ReplaceApplicationSignInExperienceRequest) ApiReplaceApplicationSignInExperienceRequest {
	r.replaceApplicationSignInExperienceRequest = &replaceApplicationSignInExperienceRequest
	return r
}

func (r ApiReplaceApplicationSignInExperienceRequest) Execute() (*GetApplicationSignInExperience200Response, *http.Response, error) {
	return r.ApiService.ReplaceApplicationSignInExperienceExecute(r)
}

/*
ReplaceApplicationSignInExperience Update application level sign-in experience

Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist. 
 - Only branding properties and terms links customization is supported for now. 

 - Only third-party applications can be customized for now. 

 - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @return ApiReplaceApplicationSignInExperienceRequest
*/
func (a *ApplicationsAPIService) ReplaceApplicationSignInExperience(ctx context.Context, applicationId string) ApiReplaceApplicationSignInExperienceRequest {
	return ApiReplaceApplicationSignInExperienceRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return GetApplicationSignInExperience200Response
func (a *ApplicationsAPIService) ReplaceApplicationSignInExperienceExecute(r ApiReplaceApplicationSignInExperienceRequest) (*GetApplicationSignInExperience200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetApplicationSignInExperience200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ReplaceApplicationSignInExperience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/sign-in-experience"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.replaceApplicationSignInExperienceRequest == nil {
		return localVarReturnValue, nil, reportError("replaceApplicationSignInExperienceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.replaceApplicationSignInExperienceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceApplicationUserConsentOrganizationsRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	userId string
	replaceApplicationUserConsentOrganizationsRequest *ReplaceApplicationUserConsentOrganizationsRequest
}

func (r ApiReplaceApplicationUserConsentOrganizationsRequest) ReplaceApplicationUserConsentOrganizationsRequest(replaceApplicationUserConsentOrganizationsRequest ReplaceApplicationUserConsentOrganizationsRequest) ApiReplaceApplicationUserConsentOrganizationsRequest {
	r.replaceApplicationUserConsentOrganizationsRequest = &replaceApplicationUserConsentOrganizationsRequest
	return r
}

func (r ApiReplaceApplicationUserConsentOrganizationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReplaceApplicationUserConsentOrganizationsExecute(r)
}

/*
ReplaceApplicationUserConsentOrganizations Grant a list of organization access of a user for a application.

Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations' access by default.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @param userId The unique identifier of the user.
 @return ApiReplaceApplicationUserConsentOrganizationsRequest
*/
func (a *ApplicationsAPIService) ReplaceApplicationUserConsentOrganizations(ctx context.Context, id string, userId string) ApiReplaceApplicationUserConsentOrganizationsRequest {
	return ApiReplaceApplicationUserConsentOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		userId: userId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ReplaceApplicationUserConsentOrganizationsExecute(r ApiReplaceApplicationUserConsentOrganizationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ReplaceApplicationUserConsentOrganizations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/users/{userId}/consent-organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.replaceApplicationUserConsentOrganizationsRequest == nil {
		return nil, reportError("replaceApplicationUserConsentOrganizationsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.replaceApplicationUserConsentOrganizationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateApplicationRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	updateApplicationRequest *UpdateApplicationRequest
}

func (r ApiUpdateApplicationRequest) UpdateApplicationRequest(updateApplicationRequest UpdateApplicationRequest) ApiUpdateApplicationRequest {
	r.updateApplicationRequest = &updateApplicationRequest
	return r
}

func (r ApiUpdateApplicationRequest) Execute() (*ListApplications200ResponseInner, *http.Response, error) {
	return r.ApiService.UpdateApplicationExecute(r)
}

/*
UpdateApplication Update application

Update application details by ID with the given data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @return ApiUpdateApplicationRequest
*/
func (a *ApplicationsAPIService) UpdateApplication(ctx context.Context, id string) ApiUpdateApplicationRequest {
	return ApiUpdateApplicationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListApplications200ResponseInner
func (a *ApplicationsAPIService) UpdateApplicationExecute(r ApiUpdateApplicationRequest) (*ListApplications200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListApplications200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.UpdateApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateApplicationRequest == nil {
		return localVarReturnValue, nil, reportError("updateApplicationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateApplicationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationCustomDataRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	applicationId string
	body *map[string]interface{}
}

func (r ApiUpdateApplicationCustomDataRequest) Body(body map[string]interface{}) ApiUpdateApplicationCustomDataRequest {
	r.body = &body
	return r
}

func (r ApiUpdateApplicationCustomDataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateApplicationCustomDataExecute(r)
}

/*
UpdateApplicationCustomData Update application custom data

Update the custom data of an application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationId The unique identifier of the application.
 @return ApiUpdateApplicationCustomDataRequest
*/
func (a *ApplicationsAPIService) UpdateApplicationCustomData(ctx context.Context, applicationId string) ApiUpdateApplicationCustomDataRequest {
	return ApiUpdateApplicationCustomDataRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ApplicationsAPIService) UpdateApplicationCustomDataExecute(r ApiUpdateApplicationCustomDataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.UpdateApplicationCustomData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{applicationId}/custom-data"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationSecretRequest struct {
	ctx context.Context
	ApiService *ApplicationsAPIService
	id string
	name string
	updateApplicationSecretRequest *UpdateApplicationSecretRequest
}

func (r ApiUpdateApplicationSecretRequest) UpdateApplicationSecretRequest(updateApplicationSecretRequest UpdateApplicationSecretRequest) ApiUpdateApplicationSecretRequest {
	r.updateApplicationSecretRequest = &updateApplicationSecretRequest
	return r
}

func (r ApiUpdateApplicationSecretRequest) Execute() (*ListApplicationSecrets200ResponseInner, *http.Response, error) {
	return r.ApiService.UpdateApplicationSecretExecute(r)
}

/*
UpdateApplicationSecret Update application secret

Update a secret for the application by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique identifier of the application.
 @param name The name of the secret.
 @return ApiUpdateApplicationSecretRequest
*/
func (a *ApplicationsAPIService) UpdateApplicationSecret(ctx context.Context, id string, name string) ApiUpdateApplicationSecretRequest {
	return ApiUpdateApplicationSecretRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		name: name,
	}
}

// Execute executes the request
//  @return ListApplicationSecrets200ResponseInner
func (a *ApplicationsAPIService) UpdateApplicationSecretExecute(r ApiUpdateApplicationSecretRequest) (*ListApplicationSecrets200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListApplicationSecrets200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.UpdateApplicationSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/applications/{id}/secrets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateApplicationSecretRequest == nil {
		return localVarReturnValue, nil, reportError("updateApplicationSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateApplicationSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
