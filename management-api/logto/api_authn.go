/*
Logto API references

API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.

API version: Cloud
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package logto

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AuthnAPIService AuthnAPI service
type AuthnAPIService service

type ApiAssertSamlRequest struct {
	ctx context.Context
	ApiService *AuthnAPIService
	connectorId string
	body *map[string]interface{}
}

func (r ApiAssertSamlRequest) Body(body map[string]interface{}) ApiAssertSamlRequest {
	r.body = &body
	return r
}

func (r ApiAssertSamlRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssertSamlExecute(r)
}

/*
AssertSaml SAML ACS endpoint (social)

The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.

SAML social connectors are deprecated. Use the SSO SAML connector instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiAssertSamlRequest

Deprecated
*/
func (a *AuthnAPIService) AssertSaml(ctx context.Context, connectorId string) ApiAssertSamlRequest {
	return ApiAssertSamlRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
// Deprecated
func (a *AuthnAPIService) AssertSamlExecute(r ApiAssertSamlRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthnAPIService.AssertSaml")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authn/saml/{connectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssertSingleSignOnSamlRequest struct {
	ctx context.Context
	ApiService *AuthnAPIService
	connectorId string
	assertSingleSignOnSamlRequest *AssertSingleSignOnSamlRequest
}

func (r ApiAssertSingleSignOnSamlRequest) AssertSingleSignOnSamlRequest(assertSingleSignOnSamlRequest AssertSingleSignOnSamlRequest) ApiAssertSingleSignOnSamlRequest {
	r.assertSingleSignOnSamlRequest = &assertSingleSignOnSamlRequest
	return r
}

func (r ApiAssertSingleSignOnSamlRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssertSingleSignOnSamlExecute(r)
}

/*
AssertSingleSignOnSaml SAML ACS endpoint (SSO)

The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.

This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectorId The unique identifier of the connector.
 @return ApiAssertSingleSignOnSamlRequest
*/
func (a *AuthnAPIService) AssertSingleSignOnSaml(ctx context.Context, connectorId string) ApiAssertSingleSignOnSamlRequest {
	return ApiAssertSingleSignOnSamlRequest{
		ApiService: a,
		ctx: ctx,
		connectorId: connectorId,
	}
}

// Execute executes the request
func (a *AuthnAPIService) AssertSingleSignOnSamlExecute(r ApiAssertSingleSignOnSamlRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthnAPIService.AssertSingleSignOnSaml")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authn/single-sign-on/saml/{connectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assertSingleSignOnSamlRequest == nil {
		return nil, reportError("assertSingleSignOnSamlRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assertSingleSignOnSamlRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetHasuraAuthRequest struct {
	ctx context.Context
	ApiService *AuthnAPIService
	resource *string
	unauthorizedRole *string
}

func (r ApiGetHasuraAuthRequest) Resource(resource string) ApiGetHasuraAuthRequest {
	r.resource = &resource
	return r
}

func (r ApiGetHasuraAuthRequest) UnauthorizedRole(unauthorizedRole string) ApiGetHasuraAuthRequest {
	r.unauthorizedRole = &unauthorizedRole
	return r
}

func (r ApiGetHasuraAuthRequest) Execute() (*GetHasuraAuth200Response, *http.Response, error) {
	return r.ApiService.GetHasuraAuthExecute(r)
}

/*
GetHasuraAuth Hasura auth hook endpoint

The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura's [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHasuraAuthRequest
*/
func (a *AuthnAPIService) GetHasuraAuth(ctx context.Context) ApiGetHasuraAuthRequest {
	return ApiGetHasuraAuthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetHasuraAuth200Response
func (a *AuthnAPIService) GetHasuraAuthExecute(r ApiGetHasuraAuthRequest) (*GetHasuraAuth200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetHasuraAuth200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthnAPIService.GetHasuraAuth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authn/hasura"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resource == nil {
		return localVarReturnValue, nil, reportError("resource is required and must be specified")
	}
	if strlen(*r.resource) < 1 {
		return localVarReturnValue, nil, reportError("resource must have at least 1 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "resource", r.resource, "form", "")
	if r.unauthorizedRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unauthorizedRole", r.unauthorizedRole, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
