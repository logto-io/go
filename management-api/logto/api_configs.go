/*
Logto API references

API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.

API version: Cloud
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package logto

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ConfigsAPIService ConfigsAPI service
type ConfigsAPIService service

type ApiDeleteJwtCustomizerRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	tokenTypePath string
}

func (r ApiDeleteJwtCustomizerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteJwtCustomizerExecute(r)
}

/*
DeleteJwtCustomizer Delete JWT customizer

Delete the JWT customizer for the given token type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tokenTypePath The token type path to delete the JWT customizer for.
 @return ApiDeleteJwtCustomizerRequest
*/
func (a *ConfigsAPIService) DeleteJwtCustomizer(ctx context.Context, tokenTypePath string) ApiDeleteJwtCustomizerRequest {
	return ApiDeleteJwtCustomizerRequest{
		ApiService: a,
		ctx: ctx,
		tokenTypePath: tokenTypePath,
	}
}

// Execute executes the request
func (a *ConfigsAPIService) DeleteJwtCustomizerExecute(r ApiDeleteJwtCustomizerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.DeleteJwtCustomizer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/jwt-customizer/{tokenTypePath}"
	localVarPath = strings.Replace(localVarPath, "{"+"tokenTypePath"+"}", url.PathEscape(parameterValueToString(r.tokenTypePath, "tokenTypePath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteOidcKeyRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	keyType string
	keyId string
}

func (r ApiDeleteOidcKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOidcKeyExecute(r)
}

/*
DeleteOidcKey Delete OIDC key

Delete an OIDC signing key by key type and key ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
 @param keyId The unique identifier of the key.
 @return ApiDeleteOidcKeyRequest
*/
func (a *ConfigsAPIService) DeleteOidcKey(ctx context.Context, keyType string, keyId string) ApiDeleteOidcKeyRequest {
	return ApiDeleteOidcKeyRequest{
		ApiService: a,
		ctx: ctx,
		keyType: keyType,
		keyId: keyId,
	}
}

// Execute executes the request
func (a *ConfigsAPIService) DeleteOidcKeyExecute(r ApiDeleteOidcKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.DeleteOidcKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/oidc/{keyType}/{keyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"keyType"+"}", url.PathEscape(parameterValueToString(r.keyType, "keyType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(parameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAdminConsoleConfigRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
}

func (r ApiGetAdminConsoleConfigRequest) Execute() (*GetAdminConsoleConfig200Response, *http.Response, error) {
	return r.ApiService.GetAdminConsoleConfigExecute(r)
}

/*
GetAdminConsoleConfig Get admin console config

Get the global configuration object for Logto Console.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAdminConsoleConfigRequest
*/
func (a *ConfigsAPIService) GetAdminConsoleConfig(ctx context.Context) ApiGetAdminConsoleConfigRequest {
	return ApiGetAdminConsoleConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAdminConsoleConfig200Response
func (a *ConfigsAPIService) GetAdminConsoleConfigExecute(r ApiGetAdminConsoleConfigRequest) (*GetAdminConsoleConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAdminConsoleConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.GetAdminConsoleConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/admin-console"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJwtCustomizerRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	tokenTypePath string
}

func (r ApiGetJwtCustomizerRequest) Execute() (*GetJwtCustomizer200Response, *http.Response, error) {
	return r.ApiService.GetJwtCustomizerExecute(r)
}

/*
GetJwtCustomizer Get JWT customizer

Get the JWT customizer for the given token type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tokenTypePath The token type to get the JWT customizer for.
 @return ApiGetJwtCustomizerRequest
*/
func (a *ConfigsAPIService) GetJwtCustomizer(ctx context.Context, tokenTypePath string) ApiGetJwtCustomizerRequest {
	return ApiGetJwtCustomizerRequest{
		ApiService: a,
		ctx: ctx,
		tokenTypePath: tokenTypePath,
	}
}

// Execute executes the request
//  @return GetJwtCustomizer200Response
func (a *ConfigsAPIService) GetJwtCustomizerExecute(r ApiGetJwtCustomizerRequest) (*GetJwtCustomizer200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetJwtCustomizer200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.GetJwtCustomizer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/jwt-customizer/{tokenTypePath}"
	localVarPath = strings.Replace(localVarPath, "{"+"tokenTypePath"+"}", url.PathEscape(parameterValueToString(r.tokenTypePath, "tokenTypePath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOidcKeysRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	keyType string
}

func (r ApiGetOidcKeysRequest) Execute() ([]GetOidcKeys200ResponseInner, *http.Response, error) {
	return r.ApiService.GetOidcKeysExecute(r)
}

/*
GetOidcKeys Get OIDC keys

Get OIDC signing keys by key type. The actual key will be redacted from the result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
 @return ApiGetOidcKeysRequest
*/
func (a *ConfigsAPIService) GetOidcKeys(ctx context.Context, keyType string) ApiGetOidcKeysRequest {
	return ApiGetOidcKeysRequest{
		ApiService: a,
		ctx: ctx,
		keyType: keyType,
	}
}

// Execute executes the request
//  @return []GetOidcKeys200ResponseInner
func (a *ConfigsAPIService) GetOidcKeysExecute(r ApiGetOidcKeysRequest) ([]GetOidcKeys200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetOidcKeys200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.GetOidcKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/oidc/{keyType}"
	localVarPath = strings.Replace(localVarPath, "{"+"keyType"+"}", url.PathEscape(parameterValueToString(r.keyType, "keyType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListJwtCustomizersRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
}

func (r ApiListJwtCustomizersRequest) Execute() ([]ListJwtCustomizers200ResponseInner, *http.Response, error) {
	return r.ApiService.ListJwtCustomizersExecute(r)
}

/*
ListJwtCustomizers Get all JWT customizers

Get all JWT customizers for the tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListJwtCustomizersRequest
*/
func (a *ConfigsAPIService) ListJwtCustomizers(ctx context.Context) ApiListJwtCustomizersRequest {
	return ApiListJwtCustomizersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListJwtCustomizers200ResponseInner
func (a *ConfigsAPIService) ListJwtCustomizersExecute(r ApiListJwtCustomizersRequest) ([]ListJwtCustomizers200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListJwtCustomizers200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.ListJwtCustomizers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/jwt-customizer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotateOidcKeysRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	keyType string
	rotateOidcKeysRequest *RotateOidcKeysRequest
}

func (r ApiRotateOidcKeysRequest) RotateOidcKeysRequest(rotateOidcKeysRequest RotateOidcKeysRequest) ApiRotateOidcKeysRequest {
	r.rotateOidcKeysRequest = &rotateOidcKeysRequest
	return r
}

func (r ApiRotateOidcKeysRequest) Execute() ([]GetOidcKeys200ResponseInner, *http.Response, error) {
	return r.ApiService.RotateOidcKeysExecute(r)
}

/*
RotateOidcKeys Rotate OIDC keys

A new key will be generated and prepend to the list of keys.

Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
 @return ApiRotateOidcKeysRequest
*/
func (a *ConfigsAPIService) RotateOidcKeys(ctx context.Context, keyType string) ApiRotateOidcKeysRequest {
	return ApiRotateOidcKeysRequest{
		ApiService: a,
		ctx: ctx,
		keyType: keyType,
	}
}

// Execute executes the request
//  @return []GetOidcKeys200ResponseInner
func (a *ConfigsAPIService) RotateOidcKeysExecute(r ApiRotateOidcKeysRequest) ([]GetOidcKeys200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetOidcKeys200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.RotateOidcKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/oidc/{keyType}/rotate"
	localVarPath = strings.Replace(localVarPath, "{"+"keyType"+"}", url.PathEscape(parameterValueToString(r.keyType, "keyType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rotateOidcKeysRequest == nil {
		return localVarReturnValue, nil, reportError("rotateOidcKeysRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rotateOidcKeysRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestJwtCustomizerRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	testJwtCustomizerRequest *TestJwtCustomizerRequest
}

func (r ApiTestJwtCustomizerRequest) TestJwtCustomizerRequest(testJwtCustomizerRequest TestJwtCustomizerRequest) ApiTestJwtCustomizerRequest {
	r.testJwtCustomizerRequest = &testJwtCustomizerRequest
	return r
}

func (r ApiTestJwtCustomizerRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TestJwtCustomizerExecute(r)
}

/*
TestJwtCustomizer Test JWT customizer

Test the JWT customizer script with the given sample context and sample token payload.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestJwtCustomizerRequest
*/
func (a *ConfigsAPIService) TestJwtCustomizer(ctx context.Context) ApiTestJwtCustomizerRequest {
	return ApiTestJwtCustomizerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigsAPIService) TestJwtCustomizerExecute(r ApiTestJwtCustomizerRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.TestJwtCustomizer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/jwt-customizer/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.testJwtCustomizerRequest == nil {
		return localVarReturnValue, nil, reportError("testJwtCustomizerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.testJwtCustomizerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAdminConsoleConfigRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	updateAdminConsoleConfigRequest *UpdateAdminConsoleConfigRequest
}

func (r ApiUpdateAdminConsoleConfigRequest) UpdateAdminConsoleConfigRequest(updateAdminConsoleConfigRequest UpdateAdminConsoleConfigRequest) ApiUpdateAdminConsoleConfigRequest {
	r.updateAdminConsoleConfigRequest = &updateAdminConsoleConfigRequest
	return r
}

func (r ApiUpdateAdminConsoleConfigRequest) Execute() (*GetAdminConsoleConfig200Response, *http.Response, error) {
	return r.ApiService.UpdateAdminConsoleConfigExecute(r)
}

/*
UpdateAdminConsoleConfig Update admin console config

Update the global configuration object for Logto Console. This method performs a partial update.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAdminConsoleConfigRequest
*/
func (a *ConfigsAPIService) UpdateAdminConsoleConfig(ctx context.Context) ApiUpdateAdminConsoleConfigRequest {
	return ApiUpdateAdminConsoleConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAdminConsoleConfig200Response
func (a *ConfigsAPIService) UpdateAdminConsoleConfigExecute(r ApiUpdateAdminConsoleConfigRequest) (*GetAdminConsoleConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAdminConsoleConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.UpdateAdminConsoleConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/admin-console"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAdminConsoleConfigRequest == nil {
		return localVarReturnValue, nil, reportError("updateAdminConsoleConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAdminConsoleConfigRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateJwtCustomizerRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	tokenTypePath string
	upsertJwtCustomizerRequest *UpsertJwtCustomizerRequest
}

func (r ApiUpdateJwtCustomizerRequest) UpsertJwtCustomizerRequest(upsertJwtCustomizerRequest UpsertJwtCustomizerRequest) ApiUpdateJwtCustomizerRequest {
	r.upsertJwtCustomizerRequest = &upsertJwtCustomizerRequest
	return r
}

func (r ApiUpdateJwtCustomizerRequest) Execute() (*GetJwtCustomizer200Response, *http.Response, error) {
	return r.ApiService.UpdateJwtCustomizerExecute(r)
}

/*
UpdateJwtCustomizer Update JWT customizer

Update the JWT customizer for the given token type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tokenTypePath The token type to update a JWT customizer for.
 @return ApiUpdateJwtCustomizerRequest
*/
func (a *ConfigsAPIService) UpdateJwtCustomizer(ctx context.Context, tokenTypePath string) ApiUpdateJwtCustomizerRequest {
	return ApiUpdateJwtCustomizerRequest{
		ApiService: a,
		ctx: ctx,
		tokenTypePath: tokenTypePath,
	}
}

// Execute executes the request
//  @return GetJwtCustomizer200Response
func (a *ConfigsAPIService) UpdateJwtCustomizerExecute(r ApiUpdateJwtCustomizerRequest) (*GetJwtCustomizer200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetJwtCustomizer200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.UpdateJwtCustomizer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/jwt-customizer/{tokenTypePath}"
	localVarPath = strings.Replace(localVarPath, "{"+"tokenTypePath"+"}", url.PathEscape(parameterValueToString(r.tokenTypePath, "tokenTypePath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.upsertJwtCustomizerRequest == nil {
		return localVarReturnValue, nil, reportError("upsertJwtCustomizerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upsertJwtCustomizerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpsertJwtCustomizerRequest struct {
	ctx context.Context
	ApiService *ConfigsAPIService
	tokenTypePath string
	upsertJwtCustomizerRequest *UpsertJwtCustomizerRequest
}

func (r ApiUpsertJwtCustomizerRequest) UpsertJwtCustomizerRequest(upsertJwtCustomizerRequest UpsertJwtCustomizerRequest) ApiUpsertJwtCustomizerRequest {
	r.upsertJwtCustomizerRequest = &upsertJwtCustomizerRequest
	return r
}

func (r ApiUpsertJwtCustomizerRequest) Execute() (*GetJwtCustomizer200Response, *http.Response, error) {
	return r.ApiService.UpsertJwtCustomizerExecute(r)
}

/*
UpsertJwtCustomizer Create or update JWT customizer

Create or update a JWT customizer for the given token type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tokenTypePath The token type to create a JWT customizer for.
 @return ApiUpsertJwtCustomizerRequest
*/
func (a *ConfigsAPIService) UpsertJwtCustomizer(ctx context.Context, tokenTypePath string) ApiUpsertJwtCustomizerRequest {
	return ApiUpsertJwtCustomizerRequest{
		ApiService: a,
		ctx: ctx,
		tokenTypePath: tokenTypePath,
	}
}

// Execute executes the request
//  @return GetJwtCustomizer200Response
func (a *ConfigsAPIService) UpsertJwtCustomizerExecute(r ApiUpsertJwtCustomizerRequest) (*GetJwtCustomizer200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetJwtCustomizer200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigsAPIService.UpsertJwtCustomizer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/configs/jwt-customizer/{tokenTypePath}"
	localVarPath = strings.Replace(localVarPath, "{"+"tokenTypePath"+"}", url.PathEscape(parameterValueToString(r.tokenTypePath, "tokenTypePath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.upsertJwtCustomizerRequest == nil {
		return localVarReturnValue, nil, reportError("upsertJwtCustomizerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upsertJwtCustomizerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
